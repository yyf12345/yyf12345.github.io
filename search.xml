<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常用HTML5</title>
    <url>/2022/01/06/HTML5/</url>
    <content><![CDATA[<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h3 id="新增语义化标签"><a href="#新增语义化标签" class="headerlink" title="新增语义化标签"></a>新增语义化标签</h3><p>以前布局，我们基本都是用div来做。div对于搜索引擎来说，是没有语义的、</p>
<ul>
<li>```html<header></header>         头部标签
<nav></nav>                导航标签
<article></article>        内容标签
<section></section>        定义文档某个区域
<aside></aside>            侧边栏标签
<footer></footer>        尾部标签
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 注意</span><br><span class="line"></span><br><span class="line">  - 这些语义化标签主要是针对搜索引擎的</span><br><span class="line">  - 这些新标签页面中可以使用多次</span><br><span class="line">  - 在IE9,需要把这些元素转换为块级元素</span><br><span class="line">  - 其实，我们移动端更喜欢使用这些标签</span><br><span class="line">  - HTML5还增加了很多其他的标签，我们后面慢慢学</span><br><span class="line"></span><br><span class="line">### 新增的多媒体标签</span><br><span class="line"></span><br><span class="line">#### 视频：&lt;video&gt;</span><br><span class="line"></span><br><span class="line">| 浏览器            | MP4                                                  | WebM | Ogg  |</span><br><span class="line">| ----------------- | ---------------------------------------------------- | ---- | ---- |</span><br><span class="line">| Intermet Explorer | YES                                                  | NO   | NO   |</span><br><span class="line">| CHrome            | YES                                                  | YES  | YES  |</span><br><span class="line">| Firefox           | YES从Firefox 21版本开始    Linux系统从Firefox 30开始 | YES  | YES  |</span><br><span class="line">| Safari            | YES                                                  | NO   | NO   |</span><br><span class="line">| Opera             | YES     从Opera 25版本开始                           | YES  | YES  |</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>兼容性处理</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">    您的浏览器不支持video标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>常见属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>视频就绪自动播放(谷歌浏览器需要添加muted来解决自动播放问题)</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>向用户显示播放控件</td>
</tr>
<tr>
<td>width</td>
<td>pixels(像素)</td>
<td>设置播放器宽度</td>
</tr>
<tr>
<td>height</td>
<td>pixels(像素)</td>
<td>设置播放器高度</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>播放完是否继续播放该视频，循环播放</td>
</tr>
<tr>
<td>preload</td>
<td>auto(预先加载视频) none(不应该预先加载视频)</td>
<td>规定是否预加载视频(如果有了autoplay就忽略该属性)</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>视频url地址</td>
</tr>
<tr>
<td>poster</td>
<td>Imgurl</td>
<td>加载等待的画面图片</td>
</tr>
<tr>
<td>muted</td>
<td>muted</td>
<td>静音播放</td>
</tr>
</tbody></table>
<h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频<audio></audio></h4><p>当前<audio>元素支持三种音频格式</audio></p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>MP3</th>
<th>Wav</th>
<th>Ogg</th>
</tr>
</thead>
<tbody><tr>
<td>Intermet Explorer</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>Chrome</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Firefox</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Safari</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Opera</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
</tbody></table>
<p>语法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>兼容性问题</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">    您的浏览器不支持audio元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>常见属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后马上播放</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则每当音频结束时重新开始播放</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>要播放的音频的URL</td>
</tr>
</tbody></table>
<h4 id="多媒体标签总结"><a href="#多媒体标签总结" class="headerlink" title="多媒体标签总结"></a>多媒体标签总结</h4><ul>
<li>音频标签和视频标签使用方法基本一致</li>
<li>浏览器支持情况不同</li>
<li>谷歌浏览器把视频和音频的自动播放禁止了</li>
<li>我们可以给视频标签添加muted属性来静音播放视频，音频不可以(可以通过JS来解决)</li>
<li>视频标签是重点，我们经常设置自动播放，不使用controls控件，循环和设置大小属性</li>
</ul>
<h3 id="新增的input类型"><a href="#新增的input类型" class="headerlink" title="新增的input类型"></a>新增的input类型</h3><table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>type=”email”</td>
<td>限制用户输入必须是Email类型</td>
</tr>
<tr>
<td>type=”url”</td>
<td>限制用户输入必须是URL类型</td>
</tr>
<tr>
<td>type=”data”</td>
<td>限制用户输入必须是日期类型</td>
</tr>
<tr>
<td>type=”time”</td>
<td>限制用户输入必须是时间类型</td>
</tr>
<tr>
<td>type=”month”</td>
<td>限制用户输入必须是月类型</td>
</tr>
<tr>
<td>type=”week”</td>
<td>限制用户输入必须是周类型</td>
</tr>
<tr>
<td>type=”number”</td>
<td>限制用户输入必须是数字类型</td>
</tr>
<tr>
<td>type=”tel”</td>
<td>手机号码</td>
</tr>
<tr>
<td>type=”search”</td>
<td>搜索框</td>
</tr>
<tr>
<td>type=”color”</td>
<td>生成一个颜色选择表单</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>required</td>
<td>required</td>
<td>表单拥有该属性表示其内容不能为空</td>
</tr>
<tr>
<td>placeholder</td>
<td>提交文本</td>
<td>表单的提示信息，存在默认值将不在显示</td>
</tr>
<tr>
<td>autofocus</td>
<td>autofocus</td>
<td>自动聚焦属性，页面加载完成自动聚焦到指定表单</td>
</tr>
<tr>
<td>autocomplete</td>
<td>off/on</td>
<td>当用户在字段开始键时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项                              默认已经打开了，如autocompete=”on”，关闭autocomplete=”off”需要放在表单内，同时加上name属性，同时成功提交</td>
</tr>
<tr>
<td>multiple</td>
<td>multiple</td>
<td>可以多选文件提交</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*可以通过以下设置方式修改placeholder里面的字体颜色*/</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::placeholder</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="classList-属性"><a href="#classList-属性" class="headerlink" title="classList 属性"></a>classList 属性</h3><p>classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。</p>
<p> 该属性用于在元素中添加，移除及切换 CSS 类。有以下方法</p>
<p><strong>添加类：</strong></p>
<p>element.classList.add(‘类名’);</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">focus.classList.add(<span class="string">&#x27;current&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>移除类：</strong></p>
<p>element.classList.remmove(‘类名’)；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">focus.classList.remove(<span class="string">&#x27;current&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>切换类：</strong></p>
<p>element.classList.toggle(‘类名’)；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">focus.classList.toggle(<span class="string">&#x27;current&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意以上方法里面，所有类名都不带点</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2021/07/03/CSS/</url>
    <content><![CDATA[<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h3><p>CSS的主要使用场景就是美化网页，布局页面</p>
<ol>
<li><p>HTML的局限性</p>
<ul>
<li>只关心内容的语义</li>
<li>十分臃肿和繁琐</li>
</ul>
</li>
<li><p>CSS-<u>网页的美容师</u></p>
<ul>
<li>CSS是层叠样式表的简称</li>
<li>是一种标记语言</li>
<li>主要设置HTML页面中的<strong>文本内容、图片的外形、版面的布局和外观显示样式</strong></li>
<li>HTML—-结构    CSS——-样式</li>
</ul>
</li>
</ol>
<h3 id="CSS语法规范"><a href="#CSS语法规范" class="headerlink" title="CSS语法规范"></a>CSS语法规范</h3><p>​        ***选择器  {  样式   } ***</p>
<p>​        给谁改样式{改什么样式}</p>
<p>​        属性值和属性值以“键对值”的形式出现，</p>
<p>​        例：front-size:12px</p>
<h3 id="CSS的书写风格"><a href="#CSS的书写风格" class="headerlink" title="CSS的书写风格"></a>CSS的书写风格</h3><ol>
<li>样式格式的书写<ul>
<li>一般写展开格式，一行放一个属性</li>
</ul>
</li>
<li>样式大小写风格<ul>
<li>样式选择器，属性名，属性关键字全部使用小写字母</li>
</ul>
</li>
<li>样式空格风格<ul>
<li>属性值前面，冒号后面，保留一个空格</li>
<li>选择器（标签）和大括号中间保留空格</li>
</ul>
</li>
</ol>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>（用于指定CSS样式的HTML标签）</p>
<h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><ul>
<li>选择器（选择符）就是根据不同的需求把不同的标签选出来，（选择标签用的)                    </li>
</ul>
<h4 id="2-基础选择器"><a href="#2-基础选择器" class="headerlink" title="2.基础选择器"></a>2.基础选择器</h4><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><ol>
<li><p>定义：标签选择器（元素选择器）是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。</p>
</li>
<li><p>语法</p>
<p>​    标签名 {</p>
<p>​            属性1： 属性值1</p>
<p>​            属性2： 属性值2</p>
<p>​            属性3： 属性值3</p>
<p>​            …</p>
<p>​    }</p>
</li>
<li><p>作用：标签选择器可以把某一类标签全部选择出来</p>
</li>
<li><p>优点：能快速为页面中同一类型的标签设置样式。</p>
</li>
<li><p>缺点：不能差异化设置，只能选择当前全部标签</p>
</li>
</ol>
<h5 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h5><ol>
<li><p>作用：可以差异化选择不同的标签，单独选一个或者某几个标签</p>
</li>
<li><p>语法</p>
<p>​    **.**类名 {</p>
<p>​            属性1：属性值；</p>
<p>​            …</p>
<p>​    }</p>
<p>结构需要用到<strong>class属性</strong>来调用class类的意思</p>
<p>例：</p>
<div class="red">变红色</div></li>
<li><p><strong>记忆口诀</strong></p>
</li>
</ol>
<ul>
<li>样式点定义，结构类(class)调用，一个或多个，开发最常用 </li>
</ul>
<ol start="4">
<li><p>尽量的使用语言，或者使用全拼音</p>
</li>
<li><p><strong>多类名</strong></p>
<ol>
<li><p>多类名的使用方式</p>
<p>​    div class=”red front20“&gt;亚瑟</p>
<ul>
<li>在class属性中写多个类名</li>
<li>多个类名中间必须用空格分</li>
</ul>
</li>
<li><p>多类名开发中的使用场景</p>
<ul>
<li>可以把一些标签元素相同的样式（共同部分）放到一个类里面</li>
<li>这些标签都可以调用这个公共类，然后调用自己独有的类</li>
<li>从而节省CSS代码，统一修改也非常方便</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h5><ol>
<li><p>作用：id选择器可以欸标有特定id的HTML元素指定特定的样式</p>
</li>
<li><p>语法：</p>
<p>​        #id名{<br>​                属性1：属性值1；</p>
<p>​                …        </p>
<p>​        }</p>
<p>​        div id=”类名”&gt;内容</p>
</li>
<li><p><strong>注意：id属性只能在每个HTML文档中出现一次</strong>。</p>
</li>
<li><p><strong><u>口径：样式#定义，结构id调用，只能调用一次，别人切勿使用。</u></strong></p>
</li>
</ol>
<h5 id="id选择器与类选择器的区别"><a href="#id选择器与类选择器的区别" class="headerlink" title="id选择器与类选择器的区别"></a>id选择器与类选择器的区别</h5><ol>
<li>类选择器（class)好比一个人的名字，一个人可以有多个名字，一个名字也可以多个人使用</li>
<li>id选择器好比人的身份证号码，全国是唯一的，不得重复</li>
<li>id选择器和类选择器最大的不同在于使用次数上</li>
<li>类选择器在修改样式中用到的最多，id选择器一般用于页面唯一性的元素上，经常和JavaScript搭配使用</li>
</ol>
<h5 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h5><ol>
<li><p>用法：通配符选择器使用  ” ***** “  定义，它表示选取页面中的所有元素（标签）</p>
</li>
<li><p>语法：</p>
<p>*{</p>
<p>​    属性1：属性值1；    </p>
<p>​    ….</p>
<p>}</p>
</li>
<li><p>通配符选择器不需要调用，自动就给所有的元素使用样式</p>
</li>
<li><p>特殊情况才使用，后面讲解使用场景（以下是清除所有元素标签的内外边距）</p>
</li>
<li><p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">   </span><br><span class="line">	margin: 0;</span><br><span class="line">   </span><br><span class="line">	padding: 0;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/.io//Users\32765\Pictures\前端照片\基础选择器.png" alt="基础选择器"></p>
<h3 id="CSS字体属性"><a href="#CSS字体属性" class="headerlink" title="CSS字体属性"></a>CSS字体属性</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>![屏幕截图 2021-03-27 122640](D:\前端\笔记\前端照片\屏幕截图 2021-03-27 122640.png)</p>
<h4 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family(字体)"></a>font-family(字体)</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">	font-family:&quot;微软雅黑&quot;；</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">	font-famliy:Arial,&quot;Microsoft Yahei&quot;,‘微	  软雅黑’；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>各个字体之间必须使用英文状态下的逗号隔开</p>
</li>
<li><p>一般情况下，如果有空格隔开的多个单词组成的字体，加引号</p>
</li>
<li><p>尽量使用系统默认自带的字体，保证在任何用户的浏览器中都能正确显示</p>
</li>
<li><p>最常见的几种字体</p>
</li>
<li><p>```html<br>body {</p>
<pre><code>font-family:&#39;Microsoft YaHei&#39;,tahoma,arial,&#39;Hiragino Sans GB&#39;;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### font-size(字体大小)</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">p &#123;</span><br><span class="line">	font-size: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>px（像素）大小是我们网页的最常用单位</p>
</li>
<li><p>谷歌浏览器默认的文字大小为16px</p>
</li>
<li><p>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小</p>
</li>
<li><p>可以给body指定整个页面文字的大小</p>
</li>
</ul>
<h4 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight(字体粗细)"></a>font-weight(字体粗细)</h4><ul>
<li><p>```html<br>.bold {</p>
<pre><code>font-weight: bold;
</code></pre>
<p>} </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- | 属性值  | 描述                                                     |</span><br><span class="line">  | ------- | -------------------------------------------------------- |</span><br><span class="line">  | normal  | 默认值（不加粗的）                                       |</span><br><span class="line">  | bold    | 定义粗体（加粗的）                                       |</span><br><span class="line">  | 100~900 | 400等同于normal，而700等同于bold注意这个数字后面不跟单位 |</span><br><span class="line"></span><br><span class="line">  实际开发中，跟习惯于用数字表示粗细</span><br><span class="line"></span><br><span class="line">#### font-style（文字样式）</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  p &#123;</span><br><span class="line">  	font-style: normal;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值，浏览器会显示标准的字体样式 font-style:normal;</td>
</tr>
<tr>
<td>italic</td>
<td>浏览器会显示斜体的字体样式</td>
</tr>
</tbody></table>
</li>
<li><p><strong>注意：平时我们很少给文字加斜体，反而要给斜体标签（em,i)给为不倾斜字体。</strong></p>
</li>
</ul>
<h4 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--body &#123;</span></span><br><span class="line"><span class="comment">	font:font-style font-weight font-size/line-height font-family;</span></span><br><span class="line"><span class="comment">&#125;--&gt;</span></span><br><span class="line">body &#123;</span><br><span class="line">	font:italic 700 16px&#x27;Microsoft yahei&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用font属性时，必须按上面语法格式中的顺序书写，<strong>不能更换顺序</strong>，并且各个属性间以空格隔开</li>
<li>不需要设置的属性可以省略（取默认值），但<strong>必须保留font-size和font-family属性</strong>，否则font属性将不起作用</li>
</ol>
<h3 id="CSS文本属性"><a href="#CSS文本属性" class="headerlink" title="CSS文本属性"></a>CSS文本属性</h3><h4 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h4><ul>
<li><p><strong>color</strong>属性用于定义文本颜色</p>
</li>
<li><p>```html<br>div {</p>
<pre><code>color: red;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- | 表示           | 属性值                        |</span><br><span class="line">  | -------------- | ----------------------------- |</span><br><span class="line">  | 预定义的颜色值 | red,green,blue                |</span><br><span class="line">  | 十六进制       | #FF0000,#FF6600,#29D794       |</span><br><span class="line">  | RGB代码        | rgb(255,0,0)或rgb(100%,0%,0%) |</span><br><span class="line"></span><br><span class="line">#### 对齐方式</span><br><span class="line"></span><br><span class="line">- **text-align**属性用于设置元素内文本内容的水平对齐方式</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  div &#123;</span><br><span class="line">  	&lt;!--本质上是让文字居中对齐--&gt;</span><br><span class="line">  	text-align: center;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>左对齐（默认值）</td>
</tr>
<tr>
<td>right</td>
<td>右对齐</td>
</tr>
<tr>
<td>center</td>
<td>居中对齐</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="装饰文本"><a href="#装饰文本" class="headerlink" title="装饰文本"></a>装饰文本</h4><ul>
<li><p><strong>text-decoration</strong>属性规定添加到文本的修饰，可以给文本加下划线、删除线、上划线等。</p>
</li>
<li><p>```html<br>div {</p>
<pre><code>text-decoration: underline;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- | 属性值       | 描述                            |</span><br><span class="line">  | ------------ | ------------------------------- |</span><br><span class="line">  | none         | 默认，没有装饰线（最常用）      |</span><br><span class="line">  | underline    | 下划线。链接a自带下划线（常用） |</span><br><span class="line">  | overline     | 上划线。                        |</span><br><span class="line">  | line-through | 删除线                          |</span><br><span class="line"></span><br><span class="line">#### 文本缩进</span><br><span class="line"></span><br><span class="line">- **text-indent**属性用来指定文本的第一行缩进，通常是将**段落的首行缩进**</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  p &#123;</span><br><span class="line">  	text-indent: 20px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>长度可以是负值</p>
</li>
<li><p>```html<br>p {</p>
<pre><code>text-indent: 2em;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **em**是一个相对单位，就是当前元素（font-size)**1个文字的大小**，如果当前元素没有设置大小，则会按照父元素的1个文字的大小。</span><br><span class="line"></span><br><span class="line">#### 行间距</span><br><span class="line"></span><br><span class="line">- line-height属性用于设置行间的距离（行高），可以控制文字行与行之间的距离</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  p &#123;</span><br><span class="line">  	line-height: 26px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CSS的引导方式"><a href="#CSS的引导方式" class="headerlink" title="CSS的引导方式"></a>CSS的引导方式</h3><h4 id="CSS的三种样式表"><a href="#CSS的三种样式表" class="headerlink" title="CSS的三种样式表"></a>CSS的三种样式表</h4><h5 id="1-内部样式表（嵌入式）"><a href="#1-内部样式表（嵌入式）" class="headerlink" title="1.内部样式表（嵌入式）"></a>1.内部样式表（嵌入式）</h5><ol>
<li><p>内部样式表(内嵌样式表)是写到html页面内部，是将所有的CSS代码抽取出来，单独放入一个<style>标签中。</p>
</li>
<li><p>```html</p>
<style>
    div {
        color: red;
        font-size: 12px;
    }
</style>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. &lt;style&gt;标签理论上可以放在HTML文档的任何位置，但一般会放在文档的&lt;head&gt;标签中</span><br><span class="line"></span><br><span class="line">4. 通过此种方式，可以方便控制当前整个页面中的元素样式设置</span><br><span class="line"></span><br><span class="line">##### 2. 行内样式表（行内式）</span><br><span class="line"></span><br><span class="line">1. ​	行内样式表（内联样式表）是在元素标签内部的style属性中设定CSS样式。&lt;u&gt;适合于修改简单样式。&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">2. ```html</span><br><span class="line">   &lt;div style=&quot;color: red;font-size: 12px;&quot;&gt;</span><br><span class="line">    青春不常在，赶紧谈恋爱</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>style其实就是标签的属性</p>
</li>
<li><p>可以控制当前的标签设置样式</p>
</li>
</ol>
<h5 id="3-外部样式表（链接式）"><a href="#3-外部样式表（链接式）" class="headerlink" title="3.外部样式表（链接式）"></a>3.外部样式表（链接式）</h5><ol>
<li><p>实际开发都是外部样式表。适合于样式比较多的情况。核心是：单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用</p>
</li>
<li><p>引入外部样式表分为两步：</p>
<ol>
<li><p>先创建一个CSS文件（可以直接在.css文件中写<style></p>
</li>
<li><p>在HTML页面中，使用<link>标签引入这个文件。</p>
</li>
<li><p>```html</p>
<link rel="stylesheet" herf="css文件路径">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### CSS引入样式总结</span><br><span class="line"></span><br><span class="line">| 样式表     | 优点                     | 缺点         | 使用情况 | 控制范围       |</span><br><span class="line">| ---------- | ------------------------ | ------------ | -------- | -------------- |</span><br><span class="line">| 行内样式表 | 书写方便，权重高         | 结构样式混写 | 较少     | 控制在一个标签 |</span><br><span class="line">| 内部样式表 | 部分结构和样式相分离     | 没有彻底分离 | 较多     | 控制在一个页面 |</span><br><span class="line">| 外部样式表 | 完全实现结构和样式相分离 | 需要引入     | **最多** | 控制多个页面   |</span><br><span class="line"></span><br><span class="line">### chrome调试工具使用</span><br><span class="line"></span><br><span class="line">#### 1.打开浏览器</span><br><span class="line"></span><br><span class="line">打开chrome浏览器，按下F12键或者点击页面空白处—&gt;检查</span><br><span class="line"></span><br><span class="line">#### 2.使用调试工具</span><br><span class="line"></span><br><span class="line">![屏幕截图 2021-03-27 220515](D:\前端\笔记\前端照片\屏幕截图 2021-03-27 220515.png)</span><br><span class="line"></span><br><span class="line">### emmet语法</span><br><span class="line"></span><br><span class="line">它使用缩写，来提高html和css的编写速度</span><br><span class="line"></span><br><span class="line">#### 快速生成HTML结构语法</span><br><span class="line"></span><br><span class="line">1. 生成标签，直接输入标签名 按tab键即可</span><br><span class="line">2. 如果想要生成多个相同标签，加上*就可以了</span><br><span class="line">3. 如果有父子关系的标签，可以用&gt;</span><br><span class="line">4. 如果有兄弟关系的标签，用+号就可以</span><br><span class="line">5. 如果生成带有类名或者id名字的，直接写.demo或者#two tab</span><br><span class="line">6. 如果生成的div类名是有顺序的，可以使用自增符号$</span><br><span class="line">7. 如果想要生成的标签里面默认显示几个文字，div&#123;文字&#125;，再按tab键</span><br><span class="line"></span><br><span class="line">#### 快速生成CSS样式语法</span><br><span class="line"></span><br><span class="line">1. 比如w200按tab键可以生成   width：200px</span><br><span class="line">2. 比如lh26 按tab键可以生成    line-height：26px</span><br><span class="line"></span><br><span class="line">### 复合选择器</span><br><span class="line"></span><br><span class="line">1. 复合选择器是建立在基础选择器上，对基础选择器进行组合形成的</span><br><span class="line"></span><br><span class="line">#### 后代选择器</span><br><span class="line"></span><br><span class="line">1. 后代选择器又称为**包含选择器**，可以选择父元素里面的子元素，其写法就是把外层标签写到前面，内层标签写在后面，中间用**空格**分割，当标签发生嵌套时，内层标签就成为外层标签的后代。</span><br><span class="line"></span><br><span class="line">2. ```html</span><br><span class="line">   &lt;style&gt;</span><br><span class="line">       &lt;!--把ol里面的li选出来改为pink--&gt;</span><br><span class="line">       ,nav ol li&#123;</span><br><span class="line">           color: pink;</span><br><span class="line">       &#125;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>可以一直往下传导</p>
</li>
<li><p>元素1和元素2可以是任意基础选择器</p>
</li>
</ol>
<h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><ol>
<li><p><strong>子元素选择器只能选择作为某元素最近一级的子元素</strong>，简单理解就是选亲儿子元素</p>
</li>
<li><p>```html<br>div&gt;p{样式声明}/<em>选择div里面所有最近一级p标签元素</em>/</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 元素1是父级，元素2是子级，最终选择的是元素2</span><br><span class="line"></span><br><span class="line">4. 元素2必须是亲儿子，其孙子、重孙之类的都不归他管，你也可以叫他亲儿子选择器</span><br><span class="line"></span><br><span class="line">#### 并集选择器</span><br><span class="line"></span><br><span class="line">1. **并集选择器可以选择多组标签，同时为他们定义相同样式**，通常用于集体声明</span><br><span class="line"></span><br><span class="line">2. ```html</span><br><span class="line">   div,p &#123;</span><br><span class="line">   	color: pink;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：最后一个后面不要加   ，</p>
</li>
</ol>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><ol>
<li><p><strong>伪类选择器用于像某些选择器添加特殊效果</strong></p>
</li>
<li><p>伪类选择器书写最大的特点是用冒号（：）表示，比如：:hover(鼠标经过时)</p>
</li>
<li><h5 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:link       /*选择所有未被访问的链接*/</span><br><span class="line">a:visited    /*选择所有已被访问的链接*/</span><br><span class="line">a:hover      /*选择鼠标指针位于其上的链接*/</span><br><span class="line">a:active     /*选择活动链接（鼠标按下未弹起的链接*/</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="4">
<li><p><strong>注意事项</strong></p>
<ol>
<li>为了确保生效，请按照LYHV的顺序声明：<ol>
<li>:link</li>
<li>:visited</li>
<li>:hover</li>
<li>:active</li>
</ol>
</li>
</ol>
</li>
<li><p>```html<br>/<em>a是标签选择器 所有的链接</em>/<br>a {</p>
<pre><code>color: gray;
</code></pre>
<p>}<br>/<em>:hover是链接伪类选择器 鼠标经过</em>/<br>a:hover {</p>
<pre><code>color: red;/*鼠标经过的时候，由原来的灰色变成                了红色*/
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### :focus伪类选择器</span><br><span class="line"></span><br><span class="line">- :focus伪类选择器用于选取获得焦点的表单元素</span><br><span class="line"></span><br><span class="line">- 焦点就是光标，一般情况&lt;input&gt;类元素才能获取，因此这个选择器主要针对于表单元素来说。</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  input:focus &#123;</span><br><span class="line">  	background-color:yellow;</span><br><span class="line">  	color: green;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="CSS元素显示模式"><a href="#CSS元素显示模式" class="headerlink" title="CSS元素显示模式"></a>CSS元素显示模式</h3><p>作用：网页标签非常多，在不同的地方会用到不同类型的标签，了解他们的特点<strong>可以更好的布局我们的网页</strong></p>
<p>定义：元素显示模式就是<u>元素(标签)以什么方式显示</u></p>
<h4 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h4><ul>
<li><p>常见的块元素有<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>等，其中<div>是最经典的块状元素</p>
</li>
<li><p>特点</p>
<ol>
<li>比较霸道，自己独占一行</li>
<li>高度，宽度，外边距以及内边距都可以控制</li>
<li>宽度默认是容器(父级宽度)的100%</li>
<li>是一个容器即盒子，里面可以放行内或者块级元素</li>
</ol>
</li>
<li><p>注意：文字类的元素内不能使用块级元素</p>
</li>
</ul>
<h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><ul>
<li><p>常见的行内元素有<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>等，其中<span>标签是最经典的行内元素，有的地方也将行内元素称为内联元素。</p>
</li>
<li><p>特点:</p>
<ol>
<li>相邻行内元素在一行上，一行可以显示多个</li>
<li>高、宽直接设置是无效的</li>
<li>默认宽度就是它本身内容的宽度</li>
<li>行内元素只能容纳文本或其他行内元素</li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li>链接里面不能再放链接</li>
<li>特殊情况链接<a>里面可以放块级元素，但是给<a>转换一下块级模式最安全</li>
</ol>
</li>
</ul>
<h4 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h4><ul>
<li>在行内元素中有几个特殊标签——<img/>、<input/>、<td>，他们同时拥有块元素和行内元素的特点。</li>
<li>特点：<ol>
<li>和相邻行内元素(行内块)在一行上，但他们之间会有空白缝隙，一行可以显示多个(行内元素特点)。</li>
<li>默认宽度就是它本身内容的宽度(行内元素的特点)</li>
<li>高度，行高、外边距以及内边距都可以控制（块级元素的特点）</li>
</ol>
</li>
</ul>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>让文字的行高等于盒子的高度，就可以让文字在当前盒子内垂直居中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">height: 40px;</span><br><span class="line">line-height:40px;</span><br></pre></td></tr></table></figure>

<h3 id="CSS的背景"><a href="#CSS的背景" class="headerlink" title="CSS的背景"></a>CSS的背景</h3><h4 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h4><ul>
<li><p>background-color属性定义元素的背景元素</p>
</li>
<li><p>```CSS<br>background-color:颜色值;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 一般情况下元素背景颜色默认是transparent(透明)</span><br><span class="line"></span><br><span class="line">#### 背景图片</span><br><span class="line"></span><br><span class="line">- background-image属性描述了元素的背景图像，实际常见于**logo**或者**一些装饰性的小图片**或者是**超大的背景图片**，优点是非常便于控制位置（精灵图也是一种运用场景）</span><br><span class="line"></span><br><span class="line">- ```css</span><br><span class="line">  background-image: none|url(背景图片的地址);</span><br></pre></td></tr></table></figure></li>
<li><table>
<thead>
<tr>
<th>参数值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>无背景图（默认的）</td>
</tr>
<tr>
<td>url</td>
<td>使用绝对或者相对地址指定背景图片</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h4><ul>
<li><p>如果需要在HTML页面上对背景图像进行平铺，可以使用background-repeat属性。</p>
</li>
<li><p>```css<br>background-repeat:repeat|no-repeat|repeat-x|repeat-y;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 默认是平铺的</span><br><span class="line"></span><br><span class="line">- | 参数值    | 作用                               |</span><br><span class="line">  | --------- | ---------------------------------- |</span><br><span class="line">  | repeat    | 背景图像在横向和纵向上平铺(默认的) |</span><br><span class="line">  | no-repeat | 背景图像不平铺                     |</span><br><span class="line">  | repeat-x  | 背景图像在横向上平铺               |</span><br><span class="line">  | repeat-y  | 背景图像在纵向平铺                 |</span><br><span class="line"></span><br><span class="line">- 背景图片会压住背景颜色</span><br><span class="line"></span><br><span class="line">#### 背景图片的位置</span><br><span class="line"></span><br><span class="line">- 利用background-position属性可以改变图片在背景中的位置</span><br><span class="line"></span><br><span class="line">- ```css</span><br><span class="line">  background-position: x y;</span><br></pre></td></tr></table></figure></li>
<li><p>参数的意思是：x坐标和y坐标、可以使用<strong>方位名词</strong>和<strong>精确单位</strong></p>
</li>
<li><table>
<thead>
<tr>
<th>参数值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>百分数|由浮点数和单位标识符组成的长度值</td>
</tr>
<tr>
<td>position</td>
<td>top|center|bottom|left|center|right方位名词</td>
</tr>
</tbody></table>
</li>
<li><p>参数值</p>
<ol>
<li><p>参数是方位名词</p>
<ul>
<li>如果指定的两个值都是方位名词，则两个值前后顺序无关，比如left  top 和  top  left 效果一致</li>
<li>如果只指定一个方位名词，另外一个省略，则第二个值默认居中对齐</li>
</ul>
</li>
<li><p>参数是精确单位</p>
<ul>
<li>如果参数值是精确坐标，那么肯定是x坐标，第二个一定是y坐标</li>
<li>如果指定一个数值，那么这个数值一定是X坐标，另一个默认垂直居中</li>
</ul>
</li>
<li><p>参数是混合单位</p>
<ul>
<li>如果指定的两个值是精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="背景图像固定（背景附着）"><a href="#背景图像固定（背景附着）" class="headerlink" title="背景图像固定（背景附着）"></a>背景图像固定（背景附着）</h4><ul>
<li><p>background-attachment属性设置背景图像是否固定或者随着页面其他部分滚动</p>
</li>
<li><p>background-attachment后期可以制作视察滚动的效果</p>
</li>
<li><p>```css<br>background-attachment : scroll | fixed</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- | 参数   |                          |</span><br><span class="line">  | ------ | ------------------------ |</span><br><span class="line">  | scroll | 背景图像是随对象内容滚动 |</span><br><span class="line">  | fixed  | 背景图像固定             |</span><br><span class="line"></span><br><span class="line">#### 背景复合写法</span><br><span class="line"></span><br><span class="line">- 我们可以把背景属性代码合并写到同一个属性background中，从而节约代码量</span><br><span class="line">- 当使用简写属性时，没有特定的书写顺序，一般习惯的顺序是：</span><br><span class="line">  1. 背景颜色</span><br><span class="line">  2. 背景图片地址</span><br><span class="line">  3. 背景平铺</span><br><span class="line">  4. 背景图像滚动</span><br><span class="line">  5. 背景图像位置</span><br><span class="line"></span><br><span class="line">#### 背景色半透明</span><br><span class="line"></span><br><span class="line">- ```css</span><br><span class="line">  background: rgba(0,0,0,0.3);</span><br></pre></td></tr></table></figure></li>
<li><p>最后一个参数是alpha透明度，取值范围在0~1之间</p>
</li>
<li><p>我们习惯把0.3的0省略掉，写成background: rgba(0,0,0,.3)；</p>
</li>
<li><p>注意：背景半透明是指盒子背景半透明，盒子内部的内容不受影响</p>
</li>
<li><p>CSS新增属性，是IE9+版本浏览器才支持的</p>
</li>
</ul>
<h3 id="CSS的三大特性"><a href="#CSS的三大特性" class="headerlink" title="CSS的三大特性"></a>CSS的三大特性</h3><h4 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h4><ul>
<li>相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题</li>
<li>原则：<ol>
<li>样式冲突，遵循的原则时就近原则</li>
<li>样式不冲突，不会层叠</li>
</ol>
</li>
</ul>
<h4 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h4><ul>
<li>CSS中的继承-子标签会继承父标签的某些样式，如文本颜色和字号。</li>
<li>子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性</li>
</ul>
<h4 id="行高的继承"><a href="#行高的继承" class="headerlink" title="行高的继承"></a>行高的继承</h4><ul>
<li><p>```css<br>body {</p>
<pre><code>font:12px/1.5 Microsoft Yahei;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 行高可以跟单位也可以不跟单位</span><br><span class="line"></span><br><span class="line">- 如果子元素么有设置行高，则会继承父元素的行高为1.5</span><br><span class="line"></span><br><span class="line">- 此使字元素的行高为：当前子元素的行高是：当前子元素的文字大小为1.5</span><br><span class="line"></span><br><span class="line">- body行高1.5 这样的写法最大的优势是里面子元素可以根据自己文字可以根据自己文字大小自动调整行高</span><br><span class="line"></span><br><span class="line">#### 优先级</span><br><span class="line"></span><br><span class="line">- 当选择器相同，则执行层叠性</span><br><span class="line"></span><br><span class="line">- 选择器不同，则根据**选择器权重**执行</span><br><span class="line"></span><br><span class="line">- **选择器权重：**</span><br><span class="line"></span><br><span class="line">  | 选择器                           | 选择器权重 |</span><br><span class="line">  | -------------------------------- | ---------- |</span><br><span class="line">  | 继承或者*                        | 0，0，0，0 |</span><br><span class="line">  | 元素选择器                       | 0，0，0，1 |</span><br><span class="line">  | 类选择器，伪类选择器，属性选择器 | 0，0，1，0 |</span><br><span class="line">  | ID选择器                         | 0，1，0，0 |</span><br><span class="line">  | 行内样式style=”  “               | 1，0，0，0 |</span><br><span class="line">  | !important                       | 无穷大     |</span><br><span class="line"></span><br><span class="line">- 注意点</span><br><span class="line"></span><br><span class="line">  1. 权重是有四组数字组成的，但不会有进位</span><br><span class="line">  2. 可以理解为类选择器永远大于元素选择器，id选择器永远大于类选择器，以此类推</span><br><span class="line">  3. 等级判断从左到右，如果某一数值相同，则判断下一位数值</span><br><span class="line">  4. **继承的权重是0**，如果该元素没有直接选中，不管父元素权重有多高，子元素得到的权重都是0</span><br><span class="line"></span><br><span class="line">##### 权重的叠加</span><br><span class="line"></span><br><span class="line">- 如果是复合选择器，则会有权重叠加，需要计算权重，**权重的叠加**</span><br><span class="line">- 权重会叠加，但永远不会有进位</span><br><span class="line"></span><br><span class="line">### 盒子模型</span><br><span class="line"></span><br><span class="line">#### 盒子模型组成</span><br><span class="line"></span><br><span class="line">- **盒子模型**：就是把HTML页面中的布局元素看作一个矩形的盒子，也就是一个承装内容的容器</span><br><span class="line">- 组成：</span><br><span class="line">  1. border边框</span><br><span class="line">  2. content内容</span><br><span class="line">  3. padding内边距</span><br><span class="line">  4. margin外边距</span><br><span class="line"></span><br><span class="line">#### 边框(border)</span><br><span class="line"></span><br><span class="line">- | 属性         | 作用                   |</span><br><span class="line">  | ------------ | ---------------------- |</span><br><span class="line">  | border-width | 定义边框粗细，单位是px |</span><br><span class="line">  | border-style | 边框的样式             |</span><br><span class="line">  | border-color | 边框的颜色             |</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">border: border-width||border-color||border-style</span><br></pre></td></tr></table></figure></li>
<li><p>常用的三个边框样式</p>
</li>
<li><table>
<thead>
<tr>
<th>solid</th>
<th>实线边框</th>
</tr>
</thead>
<tbody><tr>
<td>dashed</td>
<td>虚线边框</td>
</tr>
<tr>
<td>dotted</td>
<td>点线边框</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="边框简写"><a href="#边框简写" class="headerlink" title="边框简写"></a>边框简写</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;没有顺序</span><br></pre></td></tr></table></figure>

<h5 id="边框分开写法"><a href="#边框分开写法" class="headerlink" title="边框分开写法"></a>边框分开写法</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-top</span>:<span class="number">1px</span> solid red;<span class="comment">/*只设定边框，其余同理*/</span></span><br></pre></td></tr></table></figure>

<h5 id="表格的细线边框"><a href="#表格的细线边框" class="headerlink" title="表格的细线边框"></a>表格的细线边框</h5><ul>
<li><p>border-collapse属性控制浏览器绘制表格边框的方式。他控制相邻单元格的边框</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-collapse</span>:collapse;</span><br></pre></td></tr></table></figure></li>
<li><p>border-collapse:collapse;表示把相邻边框合并在一起</p>
</li>
</ul>
<p>边框会影响盒子的大小，在原本盒子边缘增加一圈边框</p>
<h4 id="内边距padding"><a href="#内边距padding" class="headerlink" title="内边距padding"></a>内边距padding</h4><ul>
<li><p>padding属性用于设置内边距，边框与内容之间的距离</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>padding-left</td>
<td>左内边距</td>
</tr>
<tr>
<td>padding-right</td>
<td>右内边距</td>
</tr>
<tr>
<td>padding-top</td>
<td>上内边距</td>
</tr>
<tr>
<td>padding-bottom</td>
<td>下内边距</td>
</tr>
</tbody></table>
</li>
<li><p>简写属性：</p>
<ul>
<li><p>padding属性（简写属性）可以有一到四个值</p>
</li>
<li><table>
<thead>
<tr>
<th>值的个数</th>
<th>表达意思</th>
</tr>
</thead>
<tbody><tr>
<td>padding:5px;</td>
<td>1个值，代表上下左右都有5像素内边距</td>
</tr>
<tr>
<td>padding:5px 10px</td>
<td>2个值，代表上下内边距是5像素，左右内边距是10像素</td>
</tr>
<tr>
<td>padding:5px 10px 20px</td>
<td>3个值，代表上内边距5像素 左右内边距10像素 下边距20像素</td>
</tr>
<tr>
<td>padding：5px 10px 20px 30px</td>
<td>4个值，上是5像素 右是10像素 下是20像素 左是30像素 顺时针</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>padding影响了盒子实际大小</p>
<ul>
<li>如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。</li>
<li>解决方案：如何保证效果图大小保持一致，则让width/height减去多出来的内边距大小即可</li>
</ul>
</li>
<li><p><strong>padding不会影响盒子大小的情况</strong></p>
<ul>
<li>如果盒子本身没有指定width/height属性，则此时padding不会撑开盒子大小</li>
<li>后代继承父类的宽高，此时padding不会撑开盒子大小，一直和父类盒子一样宽，不要设置宽度</li>
</ul>
</li>
</ul>
<h4 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距(margin)"></a>外边距(margin)</h4><ul>
<li><p>margin属性用于设置外边距，即控制盒子和盒子之间的距离</p>
</li>
<li><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>margin-left</td>
<td>左外边距</td>
</tr>
<tr>
<td>margin-right</td>
<td>右外边距</td>
</tr>
<tr>
<td>margin-top</td>
<td>上外边距</td>
</tr>
<tr>
<td>margin-bottom</td>
<td>下外边距</td>
</tr>
</tbody></table>
</li>
<li><p>```css<br>.two {</p>
<pre><code>margin-top: 20px;
</code></pre>
<p>}</p>
<div class="two">2</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 简写和内边距相似</span><br><span class="line"></span><br><span class="line">- 典型应用</span><br><span class="line"></span><br><span class="line">  1. 使**块状盒子**水平居中</span><br><span class="line">     1. 盒子必须指定了宽度</span><br><span class="line">     2. 盒子左右的外边距都设置为**auto**</span><br><span class="line">     3. 写法：</span><br><span class="line">        - margin-left: auto; margin-right:auto;</span><br><span class="line">        - margin: auto;</span><br><span class="line">        - margin:0 auto;</span><br><span class="line"></span><br><span class="line">  1. 行内元素或者行内块元素水平居中给其父元素添加text-align:center即可</span><br><span class="line"></span><br><span class="line">- 使用margin定义块元素的垂直外边距时，可能会出现外边距的合并</span><br><span class="line"></span><br><span class="line">- 嵌套块元素垂直外边距的塌陷</span><br><span class="line"></span><br><span class="line">  - 对于两个嵌套关系(父子关系)的块元素，父元素有上外边据同时子元素也有上外边距，此时父元素会塌陷较大的外边距值</span><br><span class="line">  - ![Snipaste_2021-03-31_09-47-35](D:\前端\笔记\前端照片\Snipaste_2021-03-31_09-47-35.png)</span><br><span class="line"></span><br><span class="line">  - 解决方案</span><br><span class="line">    1. 可以为父元素定义上边框</span><br><span class="line">    2. 可以为父元素定义上内边距</span><br><span class="line">    3. 可以为父元素添加overflow:hidden</span><br><span class="line">    4. **浮动的盒子不会有外边距合并的问题**																																																																																																																			</span><br><span class="line"></span><br><span class="line">#### 清楚内外边距</span><br><span class="line"></span><br><span class="line">- 因为网页元素会自带默认的内外边距，不同浏览器默认不一致，因此需要先清除内外边距</span><br><span class="line"></span><br><span class="line">- ```css</span><br><span class="line">  * &#123;</span><br><span class="line">  	padding:0;/*清楚内边距*/</span><br><span class="line">      margin:0;/*清楚外边距*/ </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：行内元素为了照顾兼容性，尽量只设置左右内边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了  </p>
</li>
</ul>
<h3 id="PS的基础操作"><a href="#PS的基础操作" class="headerlink" title="PS的基础操作"></a>PS的基础操作</h3><p><img src="D:\前端\笔记\前端照片\Snipaste_2021-03-31_10-22-30.png" alt=" Snipaste_2021-03-31_10-22-30"></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ol>
<li><p>布局为啥要用不同 盒子，我只想用div?</p>
<p>标签都是有语义的，合理的地方用合理的标签。比如产品标题就用h，大量文字段落就用p</p>
</li>
<li><p>为啥要用那麽多类名？</p>
<p>类名就是给每个盒子起了个名字，可以更好的找到这个盒子，选取盒子更容易，后期维护也方便</p>
</li>
<li><p>到底用margin还是padding？</p>
<p>大部分情况两个可以调用，两者各有优缺点，但是根据实际情况，总h是有更简单的方法实现</p>
</li>
<li><p>去掉li前面的项目符号（小圆点）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">list-style</span>: none;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h3><ul>
<li><p>CSS3中新增了圆角边框，这样盒子就可以变成圆角了</p>
</li>
<li><p>border-radius属性用于设置元素的外边框圆角</p>
</li>
<li><p>```css<br>border-radius:length;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- radius半径（圆的半径）原理：（椭）圆与边框的交集形成圆角效果   </span><br><span class="line"></span><br><span class="line">- 参数值可以为数值或百分比的形式</span><br><span class="line"></span><br><span class="line">- 如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为50%</span><br><span class="line"></span><br><span class="line">- 如果是个矩形，设置为高度的一半就可以做</span><br><span class="line"></span><br><span class="line">- 该属性是一个简单属性，可以跟四个值，分别为左上角，右上角，右下角，左下角</span><br><span class="line"></span><br><span class="line">- 两个数值就是对角线的角是一样的</span><br><span class="line"></span><br><span class="line">- 分开写：border-top-left-radius其余的类似</span><br><span class="line"></span><br><span class="line">### 盒子阴影</span><br><span class="line"></span><br><span class="line">- CSS中新增了盒子阴影，我们可以使用box-shadow属性为盒子添加阴影</span><br><span class="line"></span><br><span class="line">- 语法</span><br><span class="line"></span><br><span class="line">  ```css</span><br><span class="line">  box-shadow:h-sadow v-shadow blur spread color inset</span><br></pre></td></tr></table></figure></li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必需。水平阴影的位置。允许负值</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必需。垂直阴影位置。允许负值</td>
</tr>
<tr>
<td>blur</td>
<td>可选。模糊距离</td>
</tr>
<tr>
<td>spread</td>
<td>可选。阴影的尺寸</td>
</tr>
<tr>
<td>color</td>
<td>可选。阴影的颜色。请查阅CSS颜色值</td>
</tr>
<tr>
<td>inset</td>
<td>可选。将外部阴影（outset)改为内部阴影</td>
</tr>
</tbody></table>
</li>
<li><p>注意：</p>
<ol>
<li>默认的是外部阴影（outset）但不可以写这个单词，否则会导致阴影无效</li>
<li>盒子阴影不占空间，不会影响其他盒子排列</li>
</ol>
</li>
<li><p>CSS3中，我们可以使用text-shadow属性将阴影应用于文本</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">text-shadowL:h-shadow v-shadow blur color</span><br></pre></td></tr></table></figure></li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必须，水平阴影的位置，允许负值</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必需，垂直阴影的位置，允许负值</td>
</tr>
<tr>
<td>blur</td>
<td>可选，模糊的距离</td>
</tr>
<tr>
<td>color</td>
<td>可选，阴影的颜色</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="CSS浮动"><a href="#CSS浮动" class="headerlink" title="CSS浮动"></a>CSS浮动</h3><h4 id="CSS浮动-1"><a href="#CSS浮动-1" class="headerlink" title="CSS浮动"></a>CSS浮动</h4><h5 id="传统网页布局的三种方式"><a href="#传统网页布局的三种方式" class="headerlink" title="传统网页布局的三种方式"></a>传统网页布局的三种方式</h5><ul>
<li>网页布局的本质——用CSS来摆放盒子，把盒子放在相应的位置</li>
<li>CSS提供了三种网页布局方式<ul>
<li>普通流（标准流）最基本的 <ol>
<li>就是标签按照规定好默认方式排列</li>
<li>块状元素会独占一行，从上到下顺序排列</li>
<li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行</li>
</ol>
</li>
<li>浮动</li>
<li>定位</li>
</ul>
</li>
</ul>
<h5 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h5><ul>
<li><p>浮动最典型的应用：可以让多个块状元素一行内排列显示</p>
</li>
<li><p>网页布局第一准则：<strong>多个块元素纵向排列找标准流，多个块状元素横向排列找浮动。</strong></p>
</li>
<li><p>float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘接触触及包含块函数或另一个浮动框的边缘</p>
</li>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123; <span class="attribute">float</span>：属性值；&#125;</span><br></pre></td></tr></table></figure></li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>元素不浮动</td>
</tr>
<tr>
<td>left</td>
<td>元素向左浮动</td>
</tr>
<tr>
<td>right</td>
<td>元素向右浮动</td>
</tr>
</tbody></table>
</li>
<li><p>特性</p>
<ol>
<li>浮动元素会脱离标准流（脱标）</li>
<li>浮动元素会一行内显示并且元素顶部对齐</li>
<li>浮动元素会具有行内块元素的特性</li>
<li>如果显示不开会自动换行</li>
</ol>
</li>
<li><p>设置了浮动(float)的元素最重要特性：</p>
<ol>
<li>脱离标准普通流的控制(浮)移动到指定位置(动)，（俗称脱标） </li>
<li><strong>浮动的盒子不在保留原先的位置</strong></li>
<li>如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列</li>
<li>注意：浮动元素是互相贴靠再一切的（不会有缝隙）如果父级元素宽度装不下这些浮动的盒子，多出来的盒子会另起一行对齐</li>
<li>浮动的元素具有行内块元素特点，行内元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。<ul>
<li>如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，他的大小根据内容来决定</li>
<li>浮动盒子中间没有缝隙，是紧挨着一起的</li>
<li>行内元素同理</li>
</ul>
</li>
</ol>
</li>
<li><p>为了约束元素位置，我们网页布局一般采取的策略是：先用标准的父元素排列上下位置，之后内部元素采取浮动排列左右位置，符合网页布局第一准则</p>
</li>
</ul>
<h5 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h5><ul>
<li><p>原因：</p>
</li>
<li><p>由于父级盒子在很多情况下不方便给高度，但是子盒子浮动又不占位置，最后父级盒子高度为0时，就会影响下面的标准盒子</p>
</li>
<li><p>本质：</p>
<ul>
<li>本质是清除浮动元素造成的影响</li>
<li>如果父盒子本身有高度，则不需要清除浮动</li>
<li><strong>清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了</strong></li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">    <span class="attribute">clear</span>:属性值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>不允许在左侧有浮动元素 （清除左侧浮动的影响）</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素 （清除右侧浮动的影响）</td>
</tr>
<tr>
<td>both</td>
<td>同时清楚左右两侧浮动的影响</td>
</tr>
</tbody></table>
</li>
<li><p>我们实际工作中，几乎只使用<strong>clear :both;</strong></p>
</li>
<li><p>清除浮动的策略是：<strong>闭合浮动</strong></p>
</li>
<li><p>方法</p>
<ol>
<li><p>额外标签法也称为隔墙法，是W3C推荐的做法</p>
<ul>
<li><p>```html<br>.ermao {</p>
<pre><code>float:left;
</code></pre>
<p>}<br>.clear {</p>
<pre><code>clear:both;
</code></pre>
<p>}</p>
<div class="ermao">二毛</div>
<div class="clear"></div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - 优点：通俗易懂，书写方便</span><br><span class="line"></span><br><span class="line">   - 缺点：添加许多无意义 的标签，结构化较差</span><br><span class="line"></span><br><span class="line">   - **注意：要求这个新的空标签必须是块级元素**</span><br><span class="line"></span><br><span class="line">2. 父级元素添加overflow属性</span><br><span class="line"></span><br><span class="line">   - 可以给父级元素添加overflow属性，将其属性值设置为hidden、auto、scroll</span><br><span class="line">   - 优点：代码简洁</span><br><span class="line">   - 缺点：无法显示溢出的部位</span><br><span class="line"></span><br><span class="line">3. 父级添加after伪元素</span><br><span class="line"></span><br><span class="line">   - ```css</span><br><span class="line">     .clearfix:after &#123;</span><br><span class="line">     	content:&quot;&quot;;</span><br><span class="line">         display:block;</span><br><span class="line">         height:0;</span><br><span class="line">         claer:both;</span><br><span class="line">         visibility:hidden;</span><br><span class="line">     &#125;</span><br><span class="line">     .clearfix &#123;/*IE6、7专有*/</span><br><span class="line">     	*zoom:1;</span><br><span class="line">     &#125;</span><br><span class="line">     &lt;div class=&quot;clearfix&quot;&gt;</span><br><span class="line">     	&lt;div&gt;&lt;/div&gt;</span><br><span class="line">     &lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>优点：没有增加标签，结构更简单</p>
</li>
<li><p>缺点：照顾低版本浏览器</p>
</li>
</ul>
</li>
<li><p>父级添加双伪元素 </p>
<ul>
<li><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<div class="clearfix">
           <div></div>
  </div>


<pre><code>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       </span><br><span class="line">     - 优点：代码更简单</span><br><span class="line">     </span><br><span class="line">     - 缺点：照顾低版本浏览器</span><br><span class="line"></span><br><span class="line">### CSS属性书写顺序</span><br><span class="line"></span><br><span class="line">![CSS属性书写顺序](D:\前端\笔记\前端照片\CSS属性书写顺序.png)</span><br><span class="line"></span><br><span class="line">### 导航栏注意点</span><br><span class="line"></span><br><span class="line">1. 实际开发中，我们不会直接使用链接a而是用li包含链接（li+a）的做法</span><br><span class="line">2. li语义会更清晰，一看就是有条理的列表型内容</span><br><span class="line">3. 如果直接用a，搜索引擎容易辨别为有堆砌关键字（容易被搜索引擎有降权的风险），从而影响网站排名</span><br><span class="line"></span><br><span class="line">### CSS定位</span><br><span class="line"></span><br><span class="line">- 作用：可以让盒子自由的在某一盒子内移动位置或者固定到屏幕中的某一位置。并且可以压住其他盒子</span><br><span class="line"></span><br><span class="line">#### 定位组成</span><br><span class="line"></span><br><span class="line">- 定位就是在摆盒子，按照定位的方式移动盒子</span><br><span class="line">- 定位=定位模式+边偏移</span><br><span class="line">- 定位模式用于指定一个元素在文档中的定位方式</span><br><span class="line">- 边偏移则决定了该元素的最终位置</span><br><span class="line"></span><br><span class="line">##### 定位模式</span><br><span class="line"></span><br><span class="line">- 定位模式决定元素的定位方式，它通过CSS的position属性来设置，其值可以分为四个</span><br><span class="line"></span><br><span class="line">- | 值       | 语义     |</span><br><span class="line">  | -------- | -------- |</span><br><span class="line">  | static   | 静态定位 |</span><br><span class="line">  | relative | 相对定位 |</span><br><span class="line">  | absolute | 绝对定位 |</span><br><span class="line">  | fixed    | 固定定位 |</span><br><span class="line"></span><br><span class="line">###### 静态定位</span><br><span class="line"></span><br><span class="line">1. 静态定位是元素的默认定位方式，无定位的意思</span><br><span class="line"></span><br><span class="line">2. 语法：</span><br><span class="line"></span><br><span class="line">   ```CSS</span><br><span class="line">   选择器&#123; position: static; &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li><p>静态定位按照标准流特性摆放位置，它没有边偏移</p>
</li>
<li><p>静态定位在布局时很少用到</p>
</li>
</ol>
<h6 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h6><ol>
<li><p>相对定位是<strong>元素在移动位置的时候，是相对于它原来的位置来说的</strong>（自恋型）。</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: relative; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>特点</p>
<ol>
<li>他是相对于原来的位置来移动的（移动位置的时候参照点是原来自己的位置）。</li>
<li>原来在标准流的位置继续占有，后面的盒子仍然按照标准流的方式对待它（不脱标，保留原来位置）</li>
</ol>
</li>
</ol>
<h6 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h6><ol>
<li><p>绝对定位是<strong>元素在移动位置的时候，是相对于它祖先元素来说的</strong></p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: absolute; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>特点：</p>
<ol>
<li>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位</li>
<li>如果祖先元素有定位（相对，绝对，固定定位），则以最近一级的有定位祖先元素为参考点移动位置</li>
<li>绝对定位不再占有原来的位置。（脱标）</li>
</ol>
</li>
</ol>
<h6 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h6><ol>
<li><p>定义：<strong>子级是绝对定位的话，父级要用相对定位</strong></p>
</li>
<li><p>注意：</p>
<ol>
<li>子级绝对定位，不会占用位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子</li>
<li>父盒子需要加定位限制子盒子再父盒子内显示</li>
<li>父盒子布局时，需要占据位置，因此父亲只能是相对定位</li>
</ol>
</li>
<li><p>因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位</p>
</li>
<li><p>当然，子绝父相不是永远不变的，如果父元素不需要占据位置，子绝父绝也是有可能的</p>
</li>
</ol>
<h6 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h6><ol>
<li><p>固定定位是<strong>元素固定于浏览器可视区的位置</strong></p>
</li>
<li><p>使用场景：可以在浏览器页面滚动时元素的位置不会改变</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: fixed; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>特点：</p>
<ol>
<li>以浏览器的可视窗口为参照点移动元素<ul>
<li>跟父元素没有任何关系</li>
<li>不随滚动条滚动</li>
</ul>
</li>
<li>固定定位不在占有原来位置<ul>
<li>固定定位也是脱标的，其实固定定位也可以看作是一个特殊的绝对定位</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>固定定位小技巧：固定在版心右侧位置</strong></p>
<ol>
<li>让固定定位的盒子left：50%,走到浏览器可视区(也可以看作版心)的一半位置</li>
<li>让固定定位的盒子margin-left：版心宽度的一半距离。多走版心宽度的一半位置</li>
</ol>
</li>
</ol>
<h6 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h6><ol>
<li><p>粘性定位可以被认为是相对定位和固定定位的混合。Sticky粘性的</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>特点：</p>
<ol>
<li>以浏览器的可视窗口为参照点移动元素（固定定位特点）</li>
<li>粘性定位占有原来位置（相对定位特点）</li>
<li>必须添加top、left、right、bottom其中一个才有效</li>
</ol>
</li>
<li><p>缺点：兼容性差，IE不支持</p>
</li>
</ol>
<h6 id="定位总结"><a href="#定位总结" class="headerlink" title="定位总结"></a>定位总结</h6><table>
<thead>
<tr>
<th>定位模式</th>
<th>是否脱标</th>
<th>移动位置</th>
<th>是否常用</th>
</tr>
</thead>
<tbody><tr>
<td>static 静态定位</td>
<td>否</td>
<td>不能使用边偏移</td>
<td>很少</td>
</tr>
<tr>
<td>relative 相对定位</td>
<td>否（占有位置）</td>
<td>相对于自身位置移动</td>
<td>常用</td>
</tr>
<tr>
<td>absolute 绝对定位</td>
<td>是（不占用位置）</td>
<td>带有定位的父级</td>
<td>常用</td>
</tr>
<tr>
<td>fixed   固定定位</td>
<td>是（不占用位置）</td>
<td>浏览器可视区</td>
<td>常用</td>
</tr>
<tr>
<td>sticky 粘性定位</td>
<td>否（占有位置）</td>
<td>浏览器可视区</td>
<td>当前阶段很少</td>
</tr>
</tbody></table>
<h6 id="定位叠放次序"><a href="#定位叠放次序" class="headerlink" title="定位叠放次序"></a>定位叠放次序</h6><ol>
<li><p>在使用定位布局时，可能会出现盒子重叠的情况，此时，可以使用z-index来控制盒子的前后次序（z轴）</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">z-index</span>: <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ol>
<li>数值可以是正整数、负整数或0，默认是auto，数值越大，盒子越靠上</li>
<li>如果属性值相同，则按照书写顺序，后来居上</li>
<li>数字后面不能加单位</li>
<li>只有定位的盒子才有z-index属性</li>
</ol>
</li>
</ol>
<h6 id="绝对定位的盒子居中算法"><a href="#绝对定位的盒子居中算法" class="headerlink" title="绝对定位的盒子居中算法"></a>绝对定位的盒子居中算法</h6><ol>
<li>加了绝对定位的盒子不能通过margin:0 auto 水平居中，但可以通过以下计算方法实现水平和垂直居中。<ul>
<li>left: 50%; :让盒子的左侧移动到父级元素的水平中心位置</li>
<li>margin-left: -100px; : 让盒子向左移动自身宽度的一半。</li>
</ul>
</li>
</ol>
<h5 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h5><ul>
<li><p>边偏移就是定位的盒子移动到最终位置，有top、bottom、left、right4个属性</p>
</li>
<li><table>
<thead>
<tr>
<th>边偏移属性</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>top</td>
<td>top:80px;</td>
<td>顶端偏移量，定义元素相对于父元素上边线的距离</td>
</tr>
<tr>
<td>bottom</td>
<td>bottom:80px;</td>
<td>底部偏移量，定义元素相对于父元素下边线的距离</td>
</tr>
<tr>
<td>left</td>
<td>left:80px;</td>
<td>左侧偏移量，定义元素相对于父元素左边线的距离</td>
</tr>
<tr>
<td>right</td>
<td>right:80px;</td>
<td>右侧偏移量，定义元素相对于父元素右边线的距离</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li>如果一个盒子既有left属性又有right属性，则会默认执行left属性</li>
<li>如果一个盒子既有top属性又有bottom属性，则会默认执行top属性</li>
</ul>
<h4 id="定位的特殊特性"><a href="#定位的特殊特性" class="headerlink" title="定位的特殊特性"></a>定位的特殊特性</h4><ul>
<li><p>绝对定位和固定定位也和浮动类似</p>
<ol>
<li>行内元素添加绝对或者固定定位，可以直接设置高度和宽度</li>
<li>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小</li>
</ol>
</li>
<li><p>脱标的盒子不会触发外边距塌陷</p>
<ol>
<li>浮动元素、绝对定位（固定定位）元素的都不会触发外边距合并的问题</li>
</ol>
</li>
<li><p>绝对定位(固定定位)会完全压住盒子</p>
<ol>
<li>浮动元素不同，只会压住她下面标准流的盒子，但不会压住下面标准流盒子里面的文字(图片)</li>
<li>但是绝对定位(固定定位)会压住下面标准流所有的内容</li>
<li>浮动不会压住文字是因为浮动产生的目的是最初是为了做文字环绕效果。文字会围绕浮动元素</li>
</ol>
</li>
</ul>
<h3 id="元素的显示和隐藏"><a href="#元素的显示和隐藏" class="headerlink" title="元素的显示和隐藏"></a>元素的显示和隐藏</h3><ul>
<li>类似网站广告，当我们点击关闭就不见了，但是我门重新刷新页面，会重新出现！</li>
<li>本质：让一个元素在页面中隐藏或者显示出来</li>
</ul>
<h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><ul>
<li><p>display属性用于设置一个元素应如何显示</p>
</li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td>display: none;</td>
<td>隐藏对象</td>
</tr>
<tr>
<td>display: block;</td>
<td>除了转化为块级元素之外，同时还有显示元素的意思</td>
</tr>
</tbody></table>
</li>
<li><p>display隐藏元素后，不在占有原来的位置</p>
</li>
</ul>
<h4 id="visibility可见性"><a href="#visibility可见性" class="headerlink" title="visibility可见性"></a>visibility可见性</h4><ul>
<li><p>visibility属性用于指定一个元素应可见还是隐藏</p>
</li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td>visibility: visible;</td>
<td>元素可视</td>
</tr>
<tr>
<td>visibility: hidden;</td>
<td>元素隐藏</td>
</tr>
</tbody></table>
</li>
<li><p>visibility隐藏元素后，继续占有原来的位置</p>
</li>
</ul>
<h4 id="overflow溢出"><a href="#overflow溢出" class="headerlink" title="overflow溢出"></a>overflow溢出</h4><ul>
<li><p>overflow属性指定了如果内容溢出一个元素的框(超出其指定高度及宽度)时，会发生什么。</p>
</li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>不剪切内容也不添加滚动条</td>
</tr>
<tr>
<td>hidden</td>
<td>不显示超出对象尺寸的内容，超出的部分隐藏掉</td>
</tr>
<tr>
<td>scroll</td>
<td>不管超出内容否，都显示滚动条</td>
</tr>
<tr>
<td>auto</td>
<td>超出自动显示滚动条，不超出不显示滚动条</td>
</tr>
</tbody></table>
</li>
<li><p>一般情况下，我们都不想让溢出的内容显示出来，因为移除的部分真的会影响布局。</p>
</li>
<li><p>如果有定位的盒子，请慎用overflow:hidden;因为他会隐藏多余的部分</p>
</li>
</ul>
<h3 id="CSS高级技巧"><a href="#CSS高级技巧" class="headerlink" title="CSS高级技巧"></a>CSS高级技巧</h3><h4 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h4><ul>
<li><p>目的：为了有效减少服务器接受和发送请求的次数，提高页面的加载速度</p>
</li>
<li><p>使用：</p>
<ol>
<li>精灵技术主要针对于背景图片使用，就是把多个小背景图片整合到一张大图片中</li>
<li>这个大图片也称为sprites精灵图或者雪碧图</li>
<li>移动背景图片位置，此时可以使用<strong>background-position</strong></li>
<li>移动的距离就是这个目标图片的X和Y坐标，注意网页中的坐标有所不同</li>
<li>因为一般情况下往上往左移动，所以数值是负值</li>
<li>使用精灵图的时候需要精确测量，每个小背景图片的大小和位置（x轴右边走的是正值，左边走的是负值，y轴同理）</li>
<li>先x轴再y轴</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>图片文件比较大</li>
<li>图片本身放大缩小会失真</li>
<li>一旦图片制作完毕后想要更换非常复杂</li>
</ol>
</li>
</ul>
<h4 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h4><ul>
<li><p>使用场景：主要用于网页中通用、常用的一些小图标</p>
</li>
<li><p>字体图标可以为前端工程师提供一种方便高效的图标使用方式，<strong>展示的是图标，本质属于字体</strong></p>
</li>
<li><p>优点：</p>
<ol>
<li>轻量级：一个图标字体要比一系列的图像要小，一旦字体加载了，图标就会马上渲染出来，减少服务器请求</li>
<li>灵活性：本质其实就是文字，可以随意改变颜色、产生阴影、透明效果、旋转等</li>
<li>兼容性：几乎支持所有的浏览器，请放心使用</li>
</ol>
</li>
<li><p>注意：字体图小不能替代精灵技术，只是对工作中图标部分技术的提升和优化</p>
</li>
<li><p>总结：</p>
<ol>
<li>如果遇见一些结构和样式比较简单的小图标，就用字体图标</li>
<li>如果遇到一些结构和样式复杂一点的小图片，就用精灵图</li>
</ol>
</li>
<li><p>使用</p>
<ol>
<li><p>下载</p>
<ul>
<li>推荐网站<ul>
<li>icomoon字库 <a href="http://icomoom.io/">http://icomoom.io</a> </li>
<li>阿里iconfont字库<a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a></li>
</ul>
</li>
</ul>
</li>
<li><p>引入</p>
<ul>
<li><p>把下载包里的fonts文件夹放入页面根目录</p>
</li>
<li><p>在CSS样式中全局声明字体：简单理解把这些字体文件通过CSS引入到我门的页面中</p>
<p>一定要注意字体文件路径的问题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;icomoon&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.eot?7kkyc2&#x27;</span>);</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.eot?7kkyc2#iefix&#x27;</span>)<span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.ttf?7kkyc2&#x27;</span>)<span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.woff?7kkyc2&#x27;</span>)<span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.svg?7kkyc2#icomoon&#x27;</span>)<span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);</span><br><span class="line">    <span class="attribute">font-weight</span>:normal;</span><br><span class="line">    <span class="attribute">font-style</span>:normal;</span><br><span class="line">    <span class="attribute">font-display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>到demo.html中寻找到要用的字体图标，复制要用到后面的小方框</p>
</li>
<li><p>在选择器里再次写font-family：“icomoon”;5</p>
</li>
</ul>
</li>
<li><p>追加</p>
<ul>
<li><strong>import icons</strong>把压缩包里面的selection.json重新上传，然后选中自己想要新的图标，重新下载压缩包，并替换原来的文件即可。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>如果使用e91e之类的用法前面要加一个转义字符如”\e91e”</strong></p>
<h3 id="CSS三角制作"><a href="#CSS三角制作" class="headerlink" title="CSS三角制作"></a>CSS三角制作</h3><ul>
<li><p>把除了自己的其他三角全部变成透明色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*为了兼容性问题*/</span></span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">50px</span> soild transparent;</span><br><span class="line">    <span class="attribute">border-left-color</span>: pink;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">100px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a>CSS用户界面样式</h3><h4 id="更改用户鼠标样式"><a href="#更改用户鼠标样式" class="headerlink" title="更改用户鼠标样式"></a>更改用户鼠标样式</h4><ul>
<li><p>鼠标样式cursor</p>
</li>
<li><p>```css<br>li {cursor: pointer; }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标样式</span><br><span class="line"></span><br><span class="line">- | 属性值      | 描述     |</span><br><span class="line">  | ----------- | -------- |</span><br><span class="line">  | default     | 小白默认 |</span><br><span class="line">  | pointer     | 小手     |</span><br><span class="line">  | move        | 移动     |</span><br><span class="line">  | text        | 文本     |</span><br><span class="line">  | not-allowed | 禁止     |</span><br><span class="line"></span><br><span class="line">#### 表单轮廓</span><br><span class="line"></span><br><span class="line">- 轮廓线outline</span><br><span class="line"></span><br><span class="line">- 给表单添加 outline： 0；或者outline：none; 样式之后，就可以去掉默认的蓝色边框</span><br><span class="line"></span><br><span class="line">- ```css</span><br><span class="line">  input &#123;outline: none; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="防止表单域拖曳"><a href="#防止表单域拖曳" class="headerlink" title="防止表单域拖曳"></a>防止表单域拖曳</h4><ul>
<li><p>文本域可以拖曳</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>防拖曳文本域resize</p>
</li>
<li><p>```css<br>textarea {resize: none;}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### vertical-align 属性应用</span><br><span class="line"></span><br><span class="line">#### 设置居中对齐</span><br><span class="line"></span><br><span class="line">- 使用场景：经常用于设置图片或者表单（行内块元素）和文字垂直对齐</span><br><span class="line"></span><br><span class="line">- 限制：只针对于行内元素或者行内块元素有效</span><br><span class="line"></span><br><span class="line">- 语法：</span><br><span class="line"></span><br><span class="line">  ```css</span><br><span class="line">  vertical-align: baseline | top | midden | bottom</span><br></pre></td></tr></table></figure></li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>baseline</td>
<td>默认。元素放置在父元素的基线上</td>
</tr>
<tr>
<td>top</td>
<td>把元素的顶端与行中元素最高元素的顶端对齐</td>
</tr>
<tr>
<td>midden</td>
<td>把此元素放置在父元素的中部</td>
</tr>
<tr>
<td>bottom</td>
<td>把元素的顶端与行中最低的元素的顶端对齐</td>
</tr>
</tbody></table>
</li>
<li><p>类似于四线三格</p>
</li>
</ul>
<h4 id="解决默认空白缝隙问题"><a href="#解决默认空白缝隙问题" class="headerlink" title="解决默认空白缝隙问题"></a>解决默认空白缝隙问题</h4><ul>
<li>bug:图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐</li>
<li>解决办法：<ol>
<li>给图片添加vertical-align: middle | top | bottom 等。（提倡使用的）</li>
<li>把图片转化为块级元素display: block;</li>
</ol>
</li>
</ul>
<h3 id="溢出文字省略号显示"><a href="#溢出文字省略号显示" class="headerlink" title="溢出文字省略号显示"></a>溢出文字省略号显示</h3><h4 id="单行文字"><a href="#单行文字" class="headerlink" title="单行文字"></a>单行文字</h4><ul>
<li><p>条件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*先强制一行内显示文本*/</span></span><br><span class="line"><span class="attribute">white-space</span>: nowrap;<span class="comment">/*默认normal自动换行*/</span></span><br><span class="line"><span class="comment">/*超出部分隐藏*/</span></span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="comment">/*文字用省略号代替超出部分*/</span></span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h4><ul>
<li><p>多行文本溢出显示省略号，有较大的兼容性问题，适用于webKit浏览器或者移动端（移动端大部分是webkit内核）</p>
</li>
<li><p>```css<br>overflow: hidden;<br>text-overflow: ellipsis;<br>/<em>弹性伸缩盒子模型显示</em>/<br>display: -webkit-box;<br>/<em>限制在一个块元素显示的文本行数</em>/<br>-webkit-line-clamp: 2;<br>/<em>设置或者检索伸缩盒子对象的子元素的排列方式</em>/<br>-webkit-box-orient: vertical;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 网页布局总结</span><br><span class="line"></span><br><span class="line">- 通过盒子模型，清楚大部分标签就是一个盒子</span><br><span class="line"></span><br><span class="line">- 通过css浮动、定位可以让每个盒子排列成网页</span><br><span class="line"></span><br><span class="line">- 一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法</span><br><span class="line"></span><br><span class="line">  1. 标准流</span><br><span class="line"></span><br><span class="line">     可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局</span><br><span class="line"></span><br><span class="line">  2. 浮动</span><br><span class="line"></span><br><span class="line">     可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局</span><br><span class="line"></span><br><span class="line">  3. 定位</span><br><span class="line"></span><br><span class="line">     定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示，如果元素自由在某个盒子内移动就用定位布局</span><br><span class="line"></span><br><span class="line">### 常见布局技巧</span><br><span class="line"></span><br><span class="line">#### margin负值运用</span><br><span class="line"></span><br><span class="line">-  让每个盒子margin往左侧移动-1px正好压住相邻盒子的边框，就可以消除边框合并造成的不美观了</span><br><span class="line">-  鼠标经过某个盒子的时候，提高当前盒子的层级既可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加z-index)</span><br><span class="line"></span><br><span class="line">### 文字围绕浮动元素</span><br><span class="line"></span><br><span class="line">- 巧妙运用浮动元素不会压住文字的特性</span><br><span class="line"></span><br><span class="line">### 行内块巧妙运用</span><br><span class="line"></span><br><span class="line">-  利用在父元素中声明text-align：center；再将子元素转化为行内块就可以将其居中了</span><br><span class="line"></span><br><span class="line">### CSS三角巧妙运用</span><br><span class="line"></span><br><span class="line">- ![CSS三角强化](D:\前端\笔记\前端照片\CSS三角强化.png)</span><br><span class="line"></span><br><span class="line">- ```CSS</span><br><span class="line">  .box1 &#123;</span><br><span class="line">              width: 0;</span><br><span class="line">              height: 0;</span><br><span class="line">              border-top: 100px solid transparent;</span><br><span class="line">              border-right: 50px solid skyblue;</span><br><span class="line">              border-bottom: 0px solid blue;</span><br><span class="line">              border-left: 0px solid green;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>把下边框和左边框设为0，再把上边框变大</p>
</li>
<li><p>简写</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-color</span>:transparent red transparent transparent;</span><br><span class="line">    <span class="attribute">border-style</span>: soild;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">22px</span> <span class="number">8px</span> <span class="number">0</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CSS初始化"><a href="#CSS初始化" class="headerlink" title="CSS初始化"></a>CSS初始化</h3><ul>
<li>border 0照顾低版本浏览器如果图片外面包含了链接会有边框的问题</li>
<li>需要在img中取消图片底侧有空白缝隙的问题</li>
<li>button按钮 设置cursor：pointer； 当我们鼠标经过button按钮的时候，鼠标会变成小手</li>
<li>-webkit-font-smoothing:antialiased;//css3中的抗锯齿性 让文字显的更加清晰</li>
<li>Unicode编码字体：把中文字体的名称用相应的Unicode编码来代替，这样就可以有效的避免浏览器解释CSS代码的时候出现乱码的问题</li>
</ul>
<h2 id="申请免费远程服务器"><a href="#申请免费远程服务器" class="headerlink" title="申请免费远程服务器"></a>申请免费远程服务器</h2><p><a href="http://free.3v.do/">http://free.3v.do/</a></p>
<p>一定要确认FTP管理</p>
<p>使用cutftp软件 上传网站到远程服务器</p>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><ul>
<li>新增的CSS3特性有兼容性问题</li>
<li>移动端支持优于PC端</li>
</ul>
<h4 id="新增选择器"><a href="#新增选择器" class="headerlink" title="新增选择器"></a>新增选择器</h4><h5 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h5><p>属性选择器可以根据元素特有属性的来选择元素。这样就可以不借助于类或者id选择器</p>
<table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>E[att]</td>
<td>选择具有att属性的E元素</td>
</tr>
<tr>
<td>E[att=”val”]</td>
<td>选择具有att属性且属性值等于val的E元素（重点）</td>
</tr>
<tr>
<td>E[att^=”val”]</td>
<td>匹配具有att属性且值以val开头的E元素</td>
</tr>
<tr>
<td>E[att$=”val”]</td>
<td>匹配具有att属性且值以val结尾的E元素</td>
</tr>
<tr>
<td>E[att*=”val”]</td>
<td>匹配具有att属性且值中含有val的E元素</td>
</tr>
</tbody></table>
<p>类选择器和属性选择器 伪类选择器 权重都是10</p>
<h5 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h5><p>结构伪类选择器主要根据文档结构来选择器元素，常用于根据父级选择器里面的子元素</p>
<table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>E:first-child</td>
<td>匹配父元素中的第一个子元素E</td>
</tr>
<tr>
<td>E:last-child</td>
<td>匹配父元素中的最后一个E元素</td>
</tr>
<tr>
<td>E:nth-child(n)</td>
<td>匹配父元素中的第n个子元素E</td>
</tr>
<tr>
<td>E:first-of-type</td>
<td>指定类型E的第一个</td>
</tr>
<tr>
<td>E:last-of-type</td>
<td>指定类型E的最后一个</td>
</tr>
<tr>
<td>E:nth-of-type(n)</td>
<td>指定类型E的第n个</td>
</tr>
</tbody></table>
<blockquote>
<p>nth-child(n)选择某个父元素的一个或多个特定的子元素</p>
</blockquote>
<ul>
<li><p>n可以是数字，关键字和公式</p>
</li>
<li><p>n如果是数字，就是选择第n个子元素，里面数字从1开始</p>
</li>
<li><p>n如果是关键字：even偶数（把所有的偶数孩子全选），</p>
<p>​                              odd奇数 （把所有的奇数孩子全选）</p>
</li>
<li><p>n可以是公式：常见的公式如下（如果n是公式，则从0开始计算，但是第0个元素或者超出了元素的个数或被忽略，等同于选择了全部孩子）<strong>括号里必须是n</strong></p>
<table>
<thead>
<tr>
<th>公式</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>2n</td>
<td>偶数</td>
</tr>
<tr>
<td>2n+1</td>
<td>奇数</td>
</tr>
<tr>
<td>5n</td>
<td>5    10   15</td>
</tr>
<tr>
<td>n+5</td>
<td>从第5个开始（包含第五个）到最后</td>
</tr>
<tr>
<td>-n+5</td>
<td>前5个（包含第5个）…</td>
</tr>
</tbody></table>
</li>
</ul>
<h6 id="nth-child-n-和nth-of-type的区别"><a href="#nth-child-n-和nth-of-type的区别" class="headerlink" title="nth-child(n)和nth-of-type的区别"></a>nth-child(n)和nth-of-type的区别</h6><blockquote>
<p>nth-child</p>
</blockquote>
<ul>
<li>nth-child会把所有的盒子都排列成序号</li>
<li>执行的时候首先看:nth-child(1)  之后会去看 前面的div</li>
</ul>
<blockquote>
<p>nth-of-type</p>
</blockquote>
<ul>
<li>nth-of-type会把指定的盒子都排列成序号</li>
<li>先看前面指定的元素，再看nth-of-type(1)</li>
</ul>
<h5 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h5><table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>::before</td>
<td>在元素内部的前面插入内容</td>
</tr>
<tr>
<td>::after</td>
<td>在元素内部的后面插入内容</td>
</tr>
</tbody></table>
<blockquote>
<p>注意 </p>
</blockquote>
<ul>
<li>before和after创建一个元素，但是属于行内元素</li>
<li>新创建的这个元素在文档数中找不到的，所以我们称为伪元素</li>
<li>语法：element:before{}</li>
<li><strong>before和after必须有content属性</strong></li>
<li>before在父元素内容的前面创建元素，after在父元素内容的后面插入元素</li>
<li>伪元素选择器和标签选择器一样，权重为1</li>
</ul>
<blockquote>
<p>使用场景</p>
</blockquote>
<ul>
<li>配合字体图标使用</li>
<li>仿土豆显示隐藏遮罩层效果</li>
<li>为元素清除浮动</li>
</ul>
<blockquote>
<p>复习清除浮动的方法</p>
</blockquote>
<ol>
<li><p>额外标签法也成为隔墙法</p>
</li>
<li><p>父级添加overflow属性</p>
</li>
<li><p>父级添加after伪元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">	content:<span class="string">&quot;&quot;</span>;  		<span class="comment">/*伪元素必须写的属性*/</span></span><br><span class="line">    <span class="attribute">display</span>:block;		<span class="comment">/*插入元素必须是块级*/</span></span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;			<span class="comment">/*不要看见这个元素*/</span></span><br><span class="line">    claer:both;			<span class="comment">/*核心代码清除浮动*/</span></span><br><span class="line">    <span class="attribute">visibility</span>:hidden;	<span class="comment">/*不要看见这个元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>父级添加双伪元素</p>
</li>
</ol>
<h4 id="CSS3盒子模型"><a href="#CSS3盒子模型" class="headerlink" title="CSS3盒子模型"></a>CSS3盒子模型</h4><ul>
<li><p>CSS3中可以通过box-sizing来指定盒模型，有俩个值：即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变</p>
</li>
<li><p>可以分为两种情况：</p>
<ol>
<li>box-sizing:content-box盒子大小为width+padding+border（以前默认的）</li>
<li>box-sizing:border-box盒子大小为width</li>
</ol>
</li>
<li><p>如果盒子模型我们改为box-sizing:border-box,那padding和border就不会撑大盒子了（前提padding和border不会超过width宽度）</p>
</li>
</ul>
<h4 id="图片变模糊"><a href="#图片变模糊" class="headerlink" title="图片变模糊"></a>图片变模糊</h4><blockquote>
<p>CSS3滤镜filter:</p>
</blockquote>
<p>filter CSS属性将模糊或颜色偏移等图形效果应用于元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">filter</span>: 函数();</span><br><span class="line">例如：</span><br><span class="line"><span class="attribute">filter</span>:<span class="built_in">blur</span>(<span class="number">5px</span>);</span><br><span class="line">blur模糊处理 数值越大越模糊</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CSS3  calc函数</p>
</blockquote>
<p>calc()  此CSS函数    让你在声明CSS属性值时执行一些计算</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>:<span class="built_in">calc</span>(<span class="number">100%</span>-<span class="number">80px</span>);</span><br></pre></td></tr></table></figure>

<p>括号里面可以使用+ - * /来计算 </p>
<h4 id="CSS3过渡"><a href="#CSS3过渡" class="headerlink" title="CSS3过渡"></a>CSS3过渡</h4><p>过渡动画：是从一个状态渐渐过渡到另一个状态</p>
<p><strong>经常和:hover一起搭配使用</strong></p>
<blockquote>
<p>用法：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>:要过渡的属性 花费时间 运动曲线 何时开始;</span><br></pre></td></tr></table></figure>

<ol>
<li>属性：需要变化的CSS属性，宽度高度背景颜色 内外边距都可以。如果想要所有的属性都变化过渡，写一个all就可以</li>
<li>花费时间：单位是 秒 （必须写单位）比如0.5s</li>
<li>运动曲线：默认是ease（可以省略）</li>
<li>何时开始：单位是秒（必须写单位）可以设置延迟触发时间 默认是0s（可以省略）</li>
</ol>
<ul>
<li>注意：<ul>
<li>谁来变化给谁加</li>
<li>如果想要写多个属性，利用逗号进行分割</li>
</ul>
</li>
</ul>
<h4 id="网站favicon图标"><a href="#网站favicon图标" class="headerlink" title="网站favicon图标"></a>网站favicon图标</h4><ul>
<li>favicon一般用于作为缩减的网站标志，它显示在浏览器的地址或者标签上</li>
<li>目前主要浏览器都支持favicon图标</li>
<li><strong>制作：</strong><ol>
<li>把品优购的图标切成png图片</li>
<li>把png图片转化为ico图标，这就借助于第三方转换网站，比如比特虫：<a href="http://www.bitbug.net/">http://www.bitbug.net/</a></li>
</ol>
</li>
</ul>
<h4 id="网站TDK三大标签SEO优化"><a href="#网站TDK三大标签SEO优化" class="headerlink" title="网站TDK三大标签SEO优化"></a>网站TDK三大标签SEO优化</h4><ul>
<li>SEO汉译为搜索引擎优化，是一种利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名的方式</li>
<li>SEO的目的是对网站进行深度优化，从而帮助网站获取免费流量，进而在搜索引擎上提高网站的排名，提高网站的知名度</li>
<li>页面必须有三个标签用来符合SEO优化<img src="D:\前端\笔记\前端照片\TDK.png" alt="TDK"></li>
</ul>
<blockquote>
<p>title网站标题</p>
</blockquote>
<p>title具有不可替代性，是我们内页的第一个重要标签，是搜索引擎了解网页和对网页主题归属的最佳判断点</p>
<p>建议:<strong>网站名（产品名）-网站介绍</strong>（尽量不超过30个汉字）</p>
<blockquote>
<p>description网页说明</p>
</blockquote>
<p>简要说明我们网站是干什么的</p>
<p>我们提倡，description作为网站的总体业务和主题概述，多采用“我们是…”</p>
<p>“我们提供…” 、“XXX网作为…..”、”电话：010…”之类语句</p>
<blockquote>
<p>keywords关键字</p>
</blockquote>
<p>keywords是页面关键词，是搜索引擎的关注点之一</p>
<p>keywords最好限制为6~8个关键词，关键词之间用英文逗号隔开，采用关键词1，关键词2的形式。</p>
<h4 id="LOGO-SEO优化"><a href="#LOGO-SEO优化" class="headerlink" title="LOGO SEO优化"></a>LOGO SEO优化</h4><ol>
<li><p>logo里面首先放一个h1标签，目的是为了提权，告诉搜索引擎，这个地方很重要</p>
</li>
<li><p>h1里面再放一个链接，可以返回首页的，把logo的背景图片给链接即可。</p>
</li>
<li><p>为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来。</p>
<ul>
<li>方法1：text-indent移到盒子外面（text-indent;-9999px)，然后overflow:hidden,淘宝的做法</li>
<li>方法2：直接给font-size:();就看不到文字了，京东做法。</li>
</ul>
</li>
<li><p>最后给链接一个title属性，这样鼠标放到logo上就可以看到提交文字了。</p>
</li>
</ol>
<h4 id="2D转换transform"><a href="#2D转换transform" class="headerlink" title="2D转换transform"></a>2D转换transform</h4><blockquote>
<p>移动 translate</p>
</blockquote>
<ol>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">translate</span>(x,y);<span class="comment">/*也可以分开写*/</span></span><br><span class="line"><span class="comment">/*x就是x轴上移动位置y就是y轴上移动位置 中间用逗号隔开*/</span></span><br><span class="line"><span class="attribute">transform</span>:<span class="built_in">translateX</span>(n);</span><br><span class="line"><span class="attribute">transform</span>:<span class="built_in">translateY</span>(n);</span><br></pre></td></tr></table></figure></li>
<li><p>重点</p>
<ul>
<li>定义2D转换中的移动，沿着吧X和Y轴移动元素</li>
<li>translate最大的优点：不会影响到其他元素的位置</li>
<li>translate中的百分比单位是相对于自身元素的translate:(50%,50%);</li>
<li>对行内标签没有效果</li>
</ul>
</li>
</ol>
<blockquote>
<p>旋转rotate</p>
</blockquote>
<ol>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">rotate</span>(度数);</span><br></pre></td></tr></table></figure></li>
<li><p>重点</p>
<ul>
<li>rotato里面跟度数，单位是deg比如rotate\</li>
<li>角度为正时，顺时针，负时，为逆时针</li>
<li>默认旋转的中心点是元素的中心点</li>
</ul>
</li>
</ol>
<blockquote>
<p>转换中心点transform-origin</p>
</blockquote>
<ol>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>:x y;</span><br></pre></td></tr></table></figure></li>
<li><p>重点</p>
<ul>
<li>注意后面的参数x和y用空格隔开</li>
<li>x y默认转换的中心点是元素的中心点(50% 50%)</li>
<li>还可以给x和y设置像素或者方位名词（top bottom left right center)</li>
</ul>
</li>
</ol>
<blockquote>
<p>缩放scale</p>
</blockquote>
<ol>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">scale</span>(x,y);</span><br></pre></td></tr></table></figure></li>
<li><p>注意</p>
<ul>
<li>注意其中的x和y用逗号分离</li>
<li>transform:scale(1,1);高和宽都放大了一倍，想对于没有放大</li>
<li>transform:scale(2,2);宽和高都放大了2倍</li>
<li>transform:scale(2);只写了一个参数，第二个参数则和第一个参数一样，相当于scale(2,2)</li>
<li>transform:scale(0.5,0.5);缩小</li>
<li>scale缩放的最大优势是：可以设置转化中心点缩放，默认为中心点缩放，而且不影响其他盒子</li>
</ul>
</li>
</ol>
<blockquote>
<p>综合写法</p>
</blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li>同时使用多个转换，其格式为：`transform:translate() rotate() scale() … 等</li>
<li>其顺序会影响转换的效果。（先旋转会改变坐标轴方向）</li>
<li><strong>当我们同时有位移和其他属性的时候，记得要把位移放到最前面</strong></li>
</ol>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><blockquote>
<p>动画序列</p>
</blockquote>
<ul>
<li>0%是动画的开始，100%是动画的完成，这样的规划就是动画序列</li>
<li>在@keyframes(关键帧)中规划某项CSS样式，就能创建由当前样式逐渐改为新样式的动画效果</li>
<li>动画是是元素从一种样式逐渐变化为另一种样式的效果，您可以改变任意多种的样式任意多的次数</li>
<li>请以百分比来规划变化发生的时间，或用关键词”form”和“to”，等同于0%和100%</li>
<li>百分比就是总时间的划分</li>
</ul>
<blockquote>
<p>语法</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称 &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="comment">/*开始状态*/</span></span><br><span class="line">        <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">         <span class="comment">/*结束状态*/</span></span><br><span class="line">        <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*调用动画*/</span></span><br><span class="line">选择器 &#123;</span><br><span class="line">    <span class="comment">/*调用动画*/</span></span><br><span class="line">    <span class="attribute">animation-name</span>: 动画名称;</span><br><span class="line">    <span class="comment">/*持续时间*/</span></span><br><span class="line">    <span class="attribute">animation-duration</span>:持续时间;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用属性</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@keyframes</td>
<td>规划动画</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性，除了animation-play-state属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>规定@keyframes动画的名称。(必须的)</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒和毫秒，默认是0(必须的)</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线，默认是”ease”.</td>
</tr>
<tr>
<td>animation-dealy</td>
<td>规定动画何时开始，默认是0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数，默认是1，还有infinite</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向播放，默认是”normal“,alternate逆向播放</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或者暂停。默认是”normal”，alternate逆播放</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定动画结束后状态，保持forwards回到起始backwards</td>
</tr>
</tbody></table>
<blockquote>
<p>动画简写属性</p>
</blockquote>
<p>animation:动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束状态;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>:myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>前面两个属性  name   duration一定要写</li>
<li>简写属性里面不包含animation-play-state:puased; 经常和鼠标经过等其他配合使用</li>
<li>想要动画走回来，而不是直接跳回来：animation-direction:alternate</li>
<li>盒子动画结束后，停在结束位置：animation-fill-mode:forwards3</li>
</ol>
<blockquote>
<p>速度曲线细节</p>
</blockquote>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>linear</td>
<td>动画从头到尾速度是相同的。匀速</td>
</tr>
<tr>
<td>ease</td>
<td>默认。动画以低速开始，然后加快，在快结束前变慢</td>
</tr>
<tr>
<td>ease-in</td>
<td>动画以低速开始</td>
</tr>
<tr>
<td>ease-out</td>
<td>动画以低速开始</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>动画以低速开始和结束</td>
</tr>
<tr>
<td>steps()</td>
<td>指定了时间函数中的间隔数量（步长）</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<ol>
<li>animation-timing-function:规定了动画的速度曲线，默认是“ease”</li>
<li>有了steps就不要写ease或者linear了</li>
</ol>
<h4 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h4><blockquote>
<p>三维坐标系</p>
</blockquote>
<p>三维坐标系其实就是指立体空间，立体空间是由三个轴共同组</p>
<ul>
<li>x轴：水平向下        <strong>注意：x右边是正值，左边是负值</strong></li>
<li>y轴：垂直向下        <strong>注意：y下面是正值，上面是负值</strong></li>
<li>z轴：垂直屏幕        <strong>注意：往外面是正值，往里面是负值</strong></li>
</ul>
<blockquote>
<p>3D移动translate3d</p>
</blockquote>
<p>3D移动在2D的基础上多加了一个可以移动的方向，就是Z轴方向</p>
<ul>
<li>transform:translateX(100px);仅仅是在<strong>X</strong>轴上移动</li>
<li>transform:translateY(100px);仅仅是在<strong>Y</strong>轴上移动</li>
<li>transform:translateZ(100px);仅仅是在<strong>Z</strong>轴上移动</li>
<li>transform:translate3d(x,y,z);其中x,y,z分别指要移动的轴的方向的距离(x,y,z)不能省略，没有就写0</li>
</ul>
<blockquote>
<p>透视perspective</p>
</blockquote>
<p>在2D平面产生由近大远小视觉立体，但是只是效果二维的</p>
<ul>
<li>如果想要在网页产生3D效果需要透视（理解成3D物体投影在2D平面内）。 </li>
<li>模拟人类的视觉位置，可认为安排一只眼睛去看 </li>
<li>透视我们也称为视距：视距就是人的眼睛到屏幕的距离 </li>
<li>距离视觉点越近的在电脑平面成像越大，越远成像越小 </li>
<li>透视的单位是像素</li>
</ul>
<p><strong>透视写在被观察元素的父盒子上面的</strong></p>
<ul>
<li>d：就是视距，视距就是一个距离人的眼睛到屏幕的距离。 </li>
<li>z：就是 z轴，物体距离屏幕的距离，z轴越大（正值） 我们看到的物体就越大。</li>
<li><img src="D:\前端\笔记\前端照片\3D透视.png" alt="3D透视"></li>
</ul>
<blockquote>
<p>3D旋转rotate3d</p>
</blockquote>
<p>3D旋转指可以让元素在三维平面内沿着 x轴，y轴，z轴或者自定义轴进行旋转。</p>
<p><strong>语法：</strong></p>
<ul>
<li>transform:rotateX(45deg)：沿着x轴正方向旋转 45度 </li>
<li>transform:rotateY(45deg) ：沿着y轴正方向旋转 45deg </li>
<li>transform:rotateZ(45deg) ：沿着Z轴正方向旋转 45deg </li>
<li>transform:rotate3d(x,y,z,deg)： 沿着自定义轴旋转 deg为角度（了解即可）</li>
</ul>
<p>对于元素旋转的方向的判断 我们需要先学习一个左手准则</p>
<p><strong>左手准则</strong></p>
<ul>
<li>左手的手拇指指向 x轴的正方向 </li>
<li>其余手指的弯曲方向就是该元素沿着x轴旋转的方向</li>
</ul>
<p><strong>transform:rotate3d(x,y,z,deg)</strong></p>
<ul>
<li>xyz是表示旋转轴的矢量，是标示你是否希望沿着该轴旋转，最后一个标示旋转的角度</li>
<li>transform:rotate3d(1,0,0,45deg) 就是沿着x轴旋转 45deg</li>
<li>transform:rotate3d(1,1,0,45deg) 就是沿着对角线旋转 45deg</li>
</ul>
<blockquote>
<p>3D呈现transform-style</p>
</blockquote>
<ul>
<li>控制子元素是否开启三维立体环境。</li>
<li>transform-style: flat 子元素不开启3d立体空间 默认的 </li>
<li>transform-style: preserve-3d; 子元素开启立体空间 </li>
<li>代码写给父级，但是影响的是子盒子 </li>
<li>这个属性很重要，后面必用</li>
</ul>
<h2 id="浏览器的私有前缀"><a href="#浏览器的私有前缀" class="headerlink" title="浏览器的私有前缀"></a>浏览器的私有前缀</h2><ul>
<li>-moz-：代表 firefox 浏览器私有属性 </li>
<li>-ms-：代表 ie 浏览器私有属性 </li>
<li>-webkit-：代表 safari、chrome 私有属性 </li>
<li>-o-：代表 Opera 私有属性</li>
</ul>
<p><strong>推荐写法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">-webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">-o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br></pre></td></tr></table></figure>

</style></p></li></ol></li></ol>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫</title>
    <url>/2022/01/04/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="python爬虫"><a href="#python爬虫" class="headerlink" title="python爬虫"></a>python爬虫</h1><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><h3 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>requests.request()</code></td>
<td>构造一个请求，支撑以下各方法的基础方法</td>
</tr>
<tr>
<td><code>requests.get()</code></td>
<td>获取HTML网页的主要方法，对应于HTTP的GET</td>
</tr>
<tr>
<td><code>requests.head()</code></td>
<td>获取HTML网页头信息的方法，对应于HTTP的HEAD</td>
</tr>
<tr>
<td><code>requests.post()</code></td>
<td>向HTML网页提交POST请求的方法，对应于HTTP的POST</td>
</tr>
<tr>
<td><code>requests.put()</code></td>
<td>向HTML网页提交PUT请求的方法，对应于HTTP的PUT</td>
</tr>
<tr>
<td><code>requests.patch()</code></td>
<td>向HTML网页提交局部修改请求，对应于HTTP的PATCH</td>
</tr>
<tr>
<td><code>requests.delete()</code></td>
<td>向HTML页面提交删除请求，对应于HTTP的DELETE</td>
</tr>
</tbody></table>
<h4 id="requests-get"><a href="#requests-get" class="headerlink" title="requests.get()"></a><code>requests.get()</code></h4><p><code>requests.get(url, params=None, **kwargs)**</code></p>
<ul>
<li>url : 拟获取页面的url链接 </li>
<li>params : url中的额外参数，字典或字节流格式，可选  </li>
<li>**kwargs: 12个控制访问的参数</li>
</ul>
<h4 id="response对象的属性"><a href="#response对象的属性" class="headerlink" title="response对象的属性"></a>response对象的属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r.status_code</td>
<td>HTTP请求的返回状态，200表示连接成功，404表示失败</td>
</tr>
<tr>
<td>r.text</td>
<td>HTTP响应内容的字符串形式，即url对应的页面内容</td>
</tr>
<tr>
<td>r.encoding</td>
<td>从HTTP header中猜测的响应内容编码方式</td>
</tr>
<tr>
<td>r.apparent_encoding</td>
<td>从内容分析出的响应内容编码方式（备选编码方式）</td>
</tr>
<tr>
<td>r.content</td>
<td>HTTP响应内容的二进制形式</td>
</tr>
</tbody></table>
<h4 id="requests库的异常"><a href="#requests库的异常" class="headerlink" title="requests库的异常"></a>requests库的异常</h4><table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>requests.ConnectionError</td>
<td>网络连接错误异常，如DNS查询失败、拒绝连接等</td>
</tr>
<tr>
<td>requests.HTTPError</td>
<td>HTTP错误异常</td>
</tr>
<tr>
<td>requests.URLRequired</td>
<td>URL缺失异常</td>
</tr>
<tr>
<td>requests.TooManyRedirects</td>
<td>超过最大重定向次数，产生重定向异常</td>
</tr>
<tr>
<td>requests.ConnectTimeout</td>
<td>连接远程服务器超时异常</td>
</tr>
<tr>
<td>requests.Timeout</td>
<td>请求URL超时，产生超时异常</td>
</tr>
<tr>
<td>r.raise_for_status()</td>
<td>如果不是200，产生异常 requests.HTTPError</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>JS</title>
    <url>/2021/07/03/JS/</url>
    <content><![CDATA[<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><h4 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h4><ul>
<li><strong>编程：</strong>就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程</li>
<li><strong>计算机程序</strong>：就是计算机所执行的一系列的<strong>指令集合</strong>，而程序全部都是用我们所掌握的语言来编写的，所以人们要控制计算机一定要通过计算机语言向计算机发出命令</li>
</ul>
<h4 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h4><ul>
<li>计算机语言指用于人与计算机之间通讯的语言，他是人与计算机之间传递信息的媒介</li>
<li>分类：<ol>
<li><strong>机器语言</strong>：计算机最终所执行的都是机器语言，他是由0和1组成的二进制数，二进制是计算机语言的基础</li>
<li><strong>汇编语言</strong>：和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的 标识符，容易识别和记忆</li>
<li><strong>高级语言</strong>：主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言</li>
</ol>
</li>
</ul>
<h4 id="编程语言-1"><a href="#编程语言-1" class="headerlink" title="编程语言"></a>编程语言</h4><ul>
<li>定义：可以通过类似于人类语言的“语言”来控制计算机，让计算机为我们做事，这样的语言就叫做编程语言</li>
<li>编程语言是用来控制计算机的一系列指令，他有固定的格式和词汇，必须遵守 </li>
<li>如今的编程语言有两种形式：汇编语言和高级语言</li>
</ul>
<h4 id="编程语言和标记语言的区别"><a href="#编程语言和标记语言的区别" class="headerlink" title="编程语言和标记语言的区别"></a>编程语言和标记语言的区别</h4><ul>
<li>编程语言有很强的逻辑和行为能力。在编程语言里，你会看到i很多的  if else 、for、while等具有逻辑性和行为能力的指令，这是主动的</li>
<li>标记语言（html)不同于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的，他是被动的</li>
</ul>
<h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><h3 id="初识Javascript"><a href="#初识Javascript" class="headerlink" title="初识Javascript"></a>初识Javascript</h3><ul>
<li><p>js是运行在客户端的脚本语言</p>
</li>
<li><p>脚本语言：不需要编译，运行过程中由js解释器（js引擎）逐行来进行解释并执行</p>
</li>
<li><p>现在也可以基于Node.js技术进行服务器端编程</p>
</li>
<li><p>作用：</p>
<ol>
<li>表单动态效验（密码强度检测）（js产生最初的目的）</li>
<li>网页特效</li>
<li>服务端开发（Node.js）</li>
<li>桌面程序（Electron）</li>
<li>APP（Cordova）</li>
<li>控制硬件-物联网（Ruff）</li>
<li>游戏开发（cocos2d-js)</li>
</ol>
</li>
<li><p>浏览器执行js简介</p>
<ul>
<li>浏览器分为两部分<ol>
<li>渲染引擎：用来解析HTML与CSS，俗称内核，比如chrome浏览器的blink，老版本的webkit</li>
<li>js引擎：也称为JS解释器。用来读取网页中的Javascript代码，对齐处理后运行，比如chrome浏览器的v8</li>
</ol>
</li>
<li>浏览器本身不会执行js代码，而是通过内置Javascript引擎来执行JS代码。JS引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以Javascript语言归为脚本语言，会逐行解释执行。</li>
</ul>
</li>
<li><p>JS的组成</p>
<ul>
<li>Javascript语法       ECMAScript</li>
<li>页面文档对象模型   DOM</li>
<li>浏览器对象模型       BOM</li>
</ul>
</li>
<li><p>Js的书写位置</p>
<ul>
<li>行内式</li>
<li>内嵌式<ul>
<li>外部JS，新建.js文件    </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Js输入输出语句"><a href="#Js输入输出语句" class="headerlink" title="Js输入输出语句"></a>Js输入输出语句</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>归属</th>
</tr>
</thead>
<tbody><tr>
<td>alert(msg)</td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info)</td>
<td>浏览框弹出输入框，用户可以输入</td>
<td>浏览器</td>
</tr>
</tbody></table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>类似于其他编程语言</strong></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li><p>```javascript<br>var age;//声明一个名称为age的变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- var是一个JS关键字，用来声明变量。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管</span><br><span class="line"></span><br><span class="line">#### 声明的特殊情况</span><br><span class="line"></span><br><span class="line">| 情况                       | 说明                   | 结果                |</span><br><span class="line">| -------------------------- | ---------------------- | ------------------- |</span><br><span class="line">| var age ;console.log(age); | 只声明 不赋值          | undefined(未定义的) |</span><br><span class="line">| console.log(age)           | 不声明 不赋值 直接使用 | 报错                |</span><br><span class="line">| age =10;console.log(age);  | 不声明 只赋值          | 10                  |</span><br><span class="line"></span><br><span class="line">#### 变量命名规范</span><br><span class="line"></span><br><span class="line">![变量命名规范](D:\前端\笔记\前端照片\变量命名规范.png)</span><br><span class="line"></span><br><span class="line">### 数据类型</span><br><span class="line"></span><br><span class="line">#### 变量的数据类型</span><br><span class="line"></span><br><span class="line">- Javascript是一种弱类型的语言或者说动态语言。这意味着不用以前声明变量的类型，在程序运行过程中，类型会被自动确定</span><br><span class="line">- js的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的</span><br><span class="line">- js拥有动态类型，同时也意味着相同的变量可用作不同的类型</span><br><span class="line"></span><br><span class="line">#### 分类</span><br><span class="line"></span><br><span class="line">##### 简单型</span><br><span class="line"></span><br><span class="line">- | 简单数据类型 | 说明                                               | 默认值    |</span><br><span class="line">  | ------------ | -------------------------------------------------- | --------- |</span><br><span class="line">  | Number       | 数字型，包含整数型和浮点型值，如 21、0.21          | 0         |</span><br><span class="line">  | Boolean      | 布尔值类型，如true、false，等价于1和0              | false     |</span><br><span class="line">  | String       | 字符串类型，如张三，注意咱们js里面，字符串都带引号 | “   ”     |</span><br><span class="line">  | Undefined    | var a; 声明了变量a但没有给值，此时a=undefined      | undefined |</span><br><span class="line">  | Null         | var a =null ;声明了变量a为空值                     | null      |</span><br><span class="line"></span><br><span class="line">- ###### 数字型</span><br><span class="line"></span><br><span class="line">  1. 前面加0是八进制，加ox是十六进制 </span><br><span class="line"></span><br><span class="line">  2. 范围：</span><br><span class="line"></span><br><span class="line">     ```javascript</span><br><span class="line">     alert(Number.MAX_VALUE);//1.7976931348623157e+308</span><br><span class="line">     alert(Number.MIN_VALUE);//5e-324</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>三个特殊值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="literal">Infinity</span>);<span class="comment">//代表无穷大，大于任何数值</span></span><br><span class="line">alert(<span class="literal">Infinity</span>);<span class="comment">//代表无穷小，小于任何数值</span></span><br><span class="line">alert(<span class="literal">NaN</span>);<span class="comment">//代表一个分数值</span></span><br></pre></td></tr></table></figure></li>
<li><p>isNaN()这个方法用来判断一个变量是否为非数字的类型，返回true或者false</p>
<ul>
<li>x是数字，返回false</li>
<li>x不是数字，返回true</li>
</ul>
</li>
</ol>
</li>
<li><h6 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h6><ol>
<li><p>单双都可以用，但Js这里推荐用单引号</p>
</li>
<li><p>js可以做到单引号嵌套双引号，或者双引号嵌套单引号（外单内双，外双内单）</p>
</li>
<li><p>字符串转义型</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行符，n是newline的意思</td>
</tr>
<tr>
<td>\\</td>
<td>斜杠\</td>
</tr>
<tr>
<td>\‘</td>
<td>‘单引号</td>
</tr>
<tr>
<td>\“</td>
<td>”双引号</td>
</tr>
<tr>
<td>\t</td>
<td>tab缩进</td>
</tr>
<tr>
<td>\b</td>
<td>空格，b是blank的意思</td>
</tr>
</tbody></table>
</li>
<li><p>字符串长度</p>
<ul>
<li>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的length属性可以获取整个字符串的长度 </li>
</ul>
</li>
<li><p>字符串的拼接</p>
<ul>
<li>多个字符串之间可以使用+号进行拼接，其拼接方式为<strong>字符串+任何类型=拼接之后的新字符串</strong></li>
<li>拼接前会把与字符串相加的任何类型转换为字符串，在拼接成一个新的字符串</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h4><ul>
<li><p>typeof可用来获取检测变量的数据类型</p>
</li>
<li><p>```javascript<br>console.log(typeof flag);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **prompt取过来的值是字符型的**</span><br><span class="line"></span><br><span class="line">#### 数据类型转换</span><br><span class="line"></span><br><span class="line">##### 转换为字符串</span><br><span class="line"></span><br><span class="line">- | 方式               | 说明                         | 案例                                 |</span><br><span class="line">  | ------------------ | ---------------------------- | ------------------------------------ |</span><br><span class="line">  | toString()         | 转成字符串                   | var num =1; alert(num.toString());   |</span><br><span class="line">  | String()强制转换   | 转成字符串                   | var num =1; alert(String());         |</span><br><span class="line">  | **加号拼接字符串** | 和字符串拼接的结果都是字符串 | var num =1; alert(num+&quot;我是字符串&quot;); |</span><br><span class="line"></span><br><span class="line">##### 转换为数字型</span><br><span class="line"></span><br><span class="line">| 方式                   | 说明                                                  | 案例                |</span><br><span class="line">| ---------------------- | ----------------------------------------------------- | ------------------- |</span><br><span class="line">| parselnt(string)函数   | 将string类型转成整数数值型,取整（直接舍弃后面的小数） | parselnt(&#x27;78&#x27;)      |</span><br><span class="line">| parseFloat(string)函数 | 将string类型转成浮点数数值型                          | parseFloat(&#x27;78.21&#x27;) |</span><br><span class="line">| Number()强制转换函数   | 将string类型转成数值型                                | Number(&#x27;12&#x27;)        |</span><br><span class="line">| js隐式转换(-*/)        | 利用算术运算隐式转换为数值型                          | &#x27;12&#x27;-0              |</span><br><span class="line"></span><br><span class="line">##### 转换为布尔型</span><br><span class="line"></span><br><span class="line">- | 方式          | 说明                 | 案例             |</span><br><span class="line">  | ------------- | -------------------- | ---------------- |</span><br><span class="line">  | Boolean()函数 | 其他类型转换为布尔值 | Boolean(&#x27;true&#x27;); |</span><br><span class="line"></span><br><span class="line">- 代表空、否定的值会被转换为false，如‘ ’、0、NaN、null、undefined</span><br><span class="line"></span><br><span class="line">- 其余值会被转换为true</span><br><span class="line"></span><br><span class="line">### 运算符</span><br><span class="line"></span><br><span class="line">#### 算数运算符</span><br><span class="line"></span><br><span class="line">- 类似于C和C++</span><br><span class="line">- 浮点数值的最高精度是17位小数，但在进行算数计算时其精度远远不如整数</span><br><span class="line">- 不要直接判断两个浮点数是否相等</span><br><span class="line"></span><br><span class="line">#### 比较运算符</span><br><span class="line"></span><br><span class="line">- 大部分和C类似</span><br><span class="line"></span><br><span class="line">- | 运算符名称  | 说明                        | 案例      | 结果  |</span><br><span class="line">  | ----------- | --------------------------- | --------- | ----- |</span><br><span class="line">  | ==          | 判等号（会转型）            | 37==37    | true  |</span><br><span class="line">  | ===     !== | 全等 要求值和数据类型都一致 | 37===&#x27;37&#x27; | false |</span><br><span class="line"></span><br><span class="line">#### 逻辑运算符</span><br><span class="line"></span><br><span class="line">- 类似于C</span><br><span class="line">- 短路运算（逻辑中断）</span><br><span class="line">  1. 逻辑与</span><br><span class="line">     - 语法：表达式1&amp;&amp;表达式2</span><br><span class="line">     - 如果第一个表达式的值为真，则返回表达式2</span><br><span class="line">     - 如果第一个表达式的值玩为假，则返回表达式1</span><br><span class="line">  2. 逻辑或</span><br><span class="line">     - 语法：表达式1&amp;&amp;表达式2</span><br><span class="line">     - 如果第一个表达式的值为真，则返回表达式1</span><br><span class="line">     - 如果第一个表达式的值玩为假，则返回表达式2</span><br><span class="line"></span><br><span class="line">#### 运算符优先级</span><br><span class="line"></span><br><span class="line">![运算符优先级](D:\前端\笔记\前端照片\运算符优先级.png) </span><br><span class="line"></span><br><span class="line">### 数组</span><br><span class="line"></span><br><span class="line">#### 创建数组的方式</span><br><span class="line"></span><br><span class="line">- 利用new创建数组</span><br><span class="line"></span><br><span class="line">  ```javascript</span><br><span class="line">  var 数组名 =new Array();</span><br><span class="line">  var arr=new Array();//创建一个新的空数组</span><br></pre></td></tr></table></figure></li>
<li><p>利用数组字面量创建数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用数组字面量方式创建空的数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [];</span><br><span class="line"><span class="comment">//2.使用数组字面量方式创建带初始值的数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;大黄&#x27;</span>,<span class="string">&#x27;瑞奇&#x27;</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>里面可以放任意类型的变量</p>
</li>
</ul>
<h4 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h4><ul>
<li>使用“数组名.length”可以访问数组元素的数量（数组长度）</li>
<li>动态监测数组元素的个数</li>
<li>想要输出多个变量，用逗号分隔开即可</li>
</ul>
<h4 id="数组中新增元素"><a href="#数组中新增元素" class="headerlink" title="数组中新增元素"></a>数组中新增元素</h4><ul>
<li><p>通过修改length长度来实现数组扩容的目的</p>
</li>
<li><p>length属性时可读写的</p>
</li>
<li><p>新增数组元素，修改索引号，追加数组元素</p>
</li>
<li><p>```javascript<br>var arr[‘red’,’green’,’blue’];<br>arr[3]=’pink’;<br>console.log(arr);<br>arr[4]=’hotpinl’;<br>console.log(arr);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 不要直接给数组名赋值，否则会提换原来的数组内容</span><br><span class="line"></span><br><span class="line">### 函数</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  function 函数名 () &#123;</span><br><span class="line">  	函数;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果实参的个数和形参个数一致，则输出正常结果</p>
</li>
<li><p>如果实参的个数多于形参的个数 ，会取的形参的个数</p>
</li>
<li><p>如果实参的个数小于形参的个数，多于的形参定义为undefined 最终的结果就是NaN</p>
</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>return语句之后的代码不被执行</li>
<li>return只能返回一个值，如果用多个逗号隔开多个值，以最后一个为准</li>
</ul>
<h4 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h4><ul>
<li>当我们不确定有多少个参数传递时，可以使用arguments来获取，在JavaScript中，arguments实际上他还当前函数的一个内置对象，所以函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参</li>
<li>arguments展示形式是一个伪数组，因此可以进行遍历，伪数组具有以下特点：<ul>
<li>具有length属性</li>
<li>按索引的方式储存数据</li>
<li>不具备数组的push，pop等方法</li>
</ul>
</li>
</ul>
<h4 id="第二种函数表达方式"><a href="#第二种函数表达方式" class="headerlink" title="第二种函数表达方式"></a>第二种函数表达方式</h4><ul>
<li><p>var fun = function(aru) {</p>
<p>​        函数内容；</p>
<p>}</p>
<p>//调用</p>
<p>fun();</p>
</li>
<li><p>fun是变量名，不是函数名</p>
</li>
<li><p>函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值而函数表达式里面存的是函数</p>
</li>
<li><p>函数表达式也可以进行传递参数</p>
</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="作用域-es5"><a href="#作用域-es5" class="headerlink" title="作用域(es5)"></a>作用域(es5)</h4><ul>
<li><p>全局作用域</p>
<ol>
<li>整个script标签里，和.js文件里</li>
</ol>
</li>
<li><p>局部作用域</p>
<ol>
<li>在函数内部就是局部作用域</li>
<li>又叫<strong>函数作用域</strong></li>
</ol>
</li>
</ul>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul>
<li><p>全局变量</p>
<ol>
<li>在全局作用域下的变量</li>
<li><strong>在函数内部没有声明直接赋值的变量也属于全局变量</strong></li>
<li>只有在关闭浏览器的时候才会销毁，比较占内存</li>
</ol>
</li>
<li><p>局部变量</p>
<ol>
<li>在函数内部声明的变量，只能在函数内部使用</li>
<li>函数形参也属于局部变量</li>
<li>当我们程序执行完毕就会销毁，比较节约内存资源</li>
</ol>
</li>
</ul>
<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><ul>
<li>目前js没有块级作用域</li>
<li>js在es6的时候新增的块级作用域</li>
</ul>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><ul>
<li>内部函数访问外部函数的变量，采用的是链式查找的方式来决定取那个值，这种结构我们称之为作用域链</li>
<li>就近原则</li>
</ul>
<h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><h4 id="预解析-1"><a href="#预解析-1" class="headerlink" title="预解析"></a>预解析</h4><ul>
<li><p>js引擎运行分为两步：</p>
<ol>
<li><strong>预解析</strong>：js引擎会把js里面所有的var还有function提升到当前作用域的最前面</li>
<li><strong>代码执行</strong>：按照代码书写顺序从上往下执行</li>
</ol>
</li>
<li><p>预解析分为</p>
<ol>
<li><strong>变量预解析（变量提升）</strong>：把所有的变量声明提升到当前作用域的最前面   不提升赋值操作</li>
<li><strong>函数预解析（函数提升）</strong>：把所有的函数声明提升到当前作用域的最前面    不调用函数</li>
</ol>
</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul>
<li>属性：事物的特征，在对象中用属性来表示</li>
<li>方法：事物的行为，在对象中用方法来表示</li>
</ul>
<h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><ul>
<li><p>利用字面量创建数组</p>
<ol>
<li>```javascript<br>var obj {<pre><code>uname: &#39;张三丰&#39;，
age:18,
sex:&#39;男&#39;，
sayHi: function () &#123;
    console.log(Hi~);
&#125;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 里面属性或者方法我们采取键值对的形式 键 属性 ：值  属性值</span><br><span class="line"></span><br><span class="line">3. 多个属性或者方法中间用逗号隔开的</span><br><span class="line"></span><br><span class="line">4. 方法冒号后面跟的是一个匿名函数</span><br><span class="line"></span><br><span class="line">5. 使用对象的两种方式：</span><br><span class="line"></span><br><span class="line">   ```javascript</span><br><span class="line">   1.console.log(obj.uname);</span><br><span class="line">   2.console.log(obj[&#x27;age&#x27;]);</span><br><span class="line">   3.obj.sayHi();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>利用new Object创建对象</p>
<ol>
<li><p>```javascript<br>var obj= new Object();//创建了一个空的对象<br>obj.uname=’张三丰’；<br>obj.age=18;<br>obj.sex=’男’;<br>obj.sayHi=function() {</p>
<pre><code>console.log(&#39;Hi~&#39;);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 利用构造函数创建对象</span><br><span class="line"></span><br><span class="line">  1. 就是把 我们对象里面的一些相同属性和方法抽象出来封装到函数里面</span><br><span class="line"></span><br><span class="line">  2. ```javascript</span><br><span class="line">     function Star (uname,age,sex)&#123;</span><br><span class="line">         this.name=uname;</span><br><span class="line">         this.age=age;</span><br><span class="line">         this.sex=sex;</span><br><span class="line">     &#125;</span><br><span class="line">     var ldh =new Star(&#x27;刘德华&#x27;,18,&#x27;男&#x27;);//</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数名字首字母要大写</p>
</li>
<li><p>我们构造函数不需要return就可以返回结果</p>
</li>
<li><p>new的一个作用就是返回对象</p>
</li>
</ol>
</li>
</ul>
<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><ul>
<li><p>for…in语句用于对数组或者对象的属性进行循环操作</p>
</li>
<li><p>```javascript<br>for(var k in obj){</p>
<pre><code>console.log(k);//k 变量 输出 得到的是属性名
console.log(obj[k]);//obj[k]得到的是属性值
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 内置对象</span><br><span class="line"></span><br><span class="line">JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或者最基本而必要的功能（属性和方法）</span><br><span class="line"></span><br><span class="line">##### 查文档</span><br><span class="line"></span><br><span class="line">- 通过MDN/W3C来查询</span><br><span class="line"></span><br><span class="line">##### math内置对象</span><br><span class="line"></span><br><span class="line">![Math内置对象](D:\前端\笔记\前端照片\Math内置对象.png)</span><br><span class="line"></span><br><span class="line">- Math.random()</span><br><span class="line"></span><br><span class="line">  返回一个随机小数</span><br><span class="line"></span><br><span class="line">- 返回两个数之间的随机整数并且包含这两个整数	</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  function geRandom(min,max)</span><br><span class="line">  &#123;</span><br><span class="line">      return Math.floor(Math.random()*(max-min+1))+min;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Date内置对象"><a href="#Date内置对象" class="headerlink" title="Date内置对象"></a>Date内置对象</h5><ul>
<li><p>```javascript<br>//Date()日期对象 是一个构造函数必须使用new来调用创建我们的日期对象<br>var arr = new Array();//创建一个数组对象<br>var obj = new Object();//创建一个对象实例<br>//1.使用Date如果没有参数 返回当前系统的当前时间<br>var date = new Date();<br>console.log(date);<br>//2.参数常用的写法 数字型 2019，10，01或者是字符串型’2019-10-1 8:8:8’<br>var date1 = new Date(2019,10,1);<br>comsole.log(date1);//返回对不是11月是10月<br>var date2 = new Date(‘2019-10-1 8:8:8’);<br>console.log(date2);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">![日期格式化](D:\前端\笔记\前端照片\日期格式化.png)</span><br><span class="line"></span><br><span class="line">- 写星期的最好方法就是写一个数组，然后调用</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  var=[&#x27;星期日&#x27;,&#x27;星期一&#x27;,&#x27;星期二&#x27;,&#x27;星期三&#x27;,&#x27;星期四&#x27;,&#x27;星期五&#x27;,&#x27;星期六&#x27;]；</span><br><span class="line">  var day=date。getDay();</span><br><span class="line">  console.log(&#x27;今天是:&#x27;+arr[day]);</span><br></pre></td></tr></table></figure></li>
<li><p>获取日期的总的毫秒数(时间戳)</p>
<ul>
<li><p>Date对象是基于1970年1月1日（世界标准时间）起的毫秒数</p>
</li>
<li><p>通过valueOf()  getTime()获取</p>
</li>
<li><p>直接写date </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date1=+<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date1);</span><br></pre></td></tr></table></figure></li>
<li><p>H5新增方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="数组对象Array"><a href="#数组对象Array" class="headerlink" title="数组对象Array"></a>数组对象Array</h5><ul>
<li><p>创建方式</p>
<ol>
<li><p>字面量方式   var arr =[1,2,3];</p>
</li>
<li><p>new Array()   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);<span class="comment">//创建一个有两个空元素的数组，2时数组长度</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>，<span class="number">3</span>);<span class="comment">//等价于[2，3]</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>检测是否为数组</p>
<ul>
<li><p>instanceof 运算符  它可以用来检测是否为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Array.isArray()        //H5新增的方法  ie9以上版本才支持</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line"><span class="built_in">Array</span>.isArray(arr);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>添加删除数组元素的方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>push(参数1,…)</td>
<td>末尾添加一个或者多个元素，注意修改原数组</td>
<td>并返回新的长度</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组最后一个元素，把数组元素长度减一无参数，修改原数组</td>
<td>返回它删除元素的值</td>
</tr>
<tr>
<td>unshift(参数1，….)</td>
<td>向数组的开头添加一个或者更多元素，注意修改原数组</td>
<td>并返回新的长度</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组的第一个元素，数组元素减1无参数，修改原数组</td>
<td>并返回第一个元素的值</td>
</tr>
</tbody></table>
</li>
<li><p>数组排序</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>是否修改原数组</th>
</tr>
</thead>
<tbody><tr>
<td>reverse()</td>
<td>颠倒数组中元素的顺序，无参数</td>
<td>该方法会改变原理的数组 返回新数组</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组的元素进行排序</td>
<td>该方法会改变原来的数组 返回新数组</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">13</span>,<span class="number">4</span>,<span class="number">77</span>,<span class="number">1</span>,<span class="number">7</span>];</span><br><span class="line">arr1.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;<span class="comment">//按照升序排列</span></span><br><span class="line">    <span class="keyword">return</span> b-a;<span class="comment">//按照降序排列</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br></pre></td></tr></table></figure></li>
<li><p>数组索引方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>indexOf(“寻找的元素”,开始的位置)</td>
<td>数组中查找给定元素的第一个索引</td>
<td>如果存在返回索引号，如果不存在，则返回-1</td>
</tr>
<tr>
<td>IastindexOf()</td>
<td>在数组中的最后一个索引</td>
<td>如果存在返回索引号，如果不存在，则返回-1</td>
</tr>
</tbody></table>
</li>
<li><p>数组转化为字符串</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>toString()</td>
<td>把数组转换为字符串，逗号分隔每一项</td>
<td>返回一个字符串</td>
</tr>
<tr>
<td>join(‘分隔符’)</td>
<td>方法用于把数组中的所有元素转化为一个字符串</td>
<td>返回一个字符串</td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td>连接两个或多个数组 不影响原数组</td>
<td>返回一个新的项目</td>
</tr>
<tr>
<td>slice()</td>
<td>数组截胡slice(begin,end)</td>
<td>返回被截胡项目的新数组</td>
</tr>
<tr>
<td>splice()</td>
<td>数组删除splic(第几个开始，要删除的个数)</td>
<td>返回被删除项目的新数组，注意，这个会影响原数组</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><ul>
<li><p>基本包装类型</p>
<ul>
<li><p>为了方便操作基本数据类型，js还提供了三个特殊引用类型：String、Number、Boolean</p>
</li>
<li><p>基本包装类型就是把简单数据类型包装为复杂数据类型，这样基本数据类型就有了属性和方法</p>
</li>
<li><p>```javascript<br>//下面代码有什么问题？<br>var str = ‘andy’;<br>console.log(str.length);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  基本数据类型是没有属性和方法，而对象才有属性和方法，但上面代码却可以执行，这是因为js会把基本数据类型包裹为复杂数据类型，其执行过程如下：</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  //1.生成临时变量，把简单类型包装为复杂数据类型</span><br><span class="line">  var temp = new String(&#x27;andy&#x27;);</span><br><span class="line">  //2.赋值给我们声明的字符变量</span><br><span class="line">  str = temp;</span><br><span class="line">  //3.销毁临时变量</span><br><span class="line">  temp = null;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字符串的不可变</p>
</li>
<li><p>不要大量拼接字符串</p>
</li>
<li><p>根据字符返回位置</p>
<ul>
<li><p>字符串所有的方法，都不会修改字符串本身（字符串是不可变的），操作完成会返回一个新的字符串</p>
</li>
<li><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>indexOf(‘要查找的字符’,’开始的位置’)；</td>
<td>返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是index索引号</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>从后i往前找，只找第一个匹配的</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>根据位置返回串</p>
<ul>
<li><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>charAt(index)</td>
<td>获取指定位置的字符(index  字符的索引号)</td>
<td>str.charAt(0)</td>
</tr>
<tr>
<td>charCodeAt(index)</td>
<td>获取指定位置字符的ASCll码（index索引号）</td>
<td>str,charCodeAt()</td>
</tr>
<tr>
<td>str[index]</td>
<td>获取指定位置的字符</td>
<td>HTML5,IE8+支持和charAt()等效</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>字符串操作方法</p>
<p><img src="/.io//前端\笔记\前端照片\字符串操作方法.png" alt="字符串操作方法"></p>
</li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ul>
<li>```javascript<pre><code>function Person(name, age) &#123;
    this.name = name;
    this.age = age;
    this.sayHello = function() &#123;
        alert(this.name);
    &#125;
&#125;
      Person(&#39;vcedqwa&#39;,14);//构造函数
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 继承</span><br><span class="line"></span><br><span class="line">- 通过普通函数调用this指向window</span><br><span class="line"></span><br><span class="line">- 通过对象的成员函数调用this指向对象</span><br><span class="line"></span><br><span class="line">- 继承时二选一就可</span><br><span class="line"></span><br><span class="line">  - apply传递的是this和以数组形式</span><br><span class="line"></span><br><span class="line">  - call传递的是单个的值</span><br><span class="line"></span><br><span class="line">  - ```javascript</span><br><span class="line">    Person.apply(this, [name, age]);</span><br><span class="line">    Person.call(this, name, age);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><ul>
<li><p>原型propotype </p>
</li>
<li><p>```javascript<br>//使用new创建对象执行了那几步<br>//1.创建一个对象<br>//属性—__proto__，指向了构造函数的原型<br>//2.将this指向这个对象<br>//3.执行构造函数<br>//4.返回这个对象<br>var p = new Person();</p>
<p>p.sayHello();</p>
<p>//当访问一定一个对象的属性的时候，首先在这个对象本身进行查找<br>//如果找到，就直接返回这个属性，且停止查找<br>//如果没找到，会继续在原型上找，也就是__proto__指向的那个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 混合继承</span><br><span class="line"></span><br><span class="line">- 属性放到对象上，方法放到原型上	</span><br><span class="line"></span><br><span class="line">- 属性既不会子类或者某个对象给改变，也保证了所有的函数能被所以的对象所共享</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">      function Person(name, age) &#123;</span><br><span class="line">          this.name = nmae;</span><br><span class="line">          this.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">      Person.prototype.sayHello = function() &#123;</span><br><span class="line">          alert(this.name);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      function Student(name, age, id) &#123;</span><br><span class="line">          Person.apply(this, [name, age]);</span><br><span class="line">          this.id = id;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      Student.prototype = Object.create(Person.prototype);</span><br><span class="line">      Student.prototype.study = function() &#123;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="简单数据类型和复杂数据类型"><a href="#简单数据类型和复杂数据类型" class="headerlink" title="简单数据类型和复杂数据类型"></a>简单数据类型和复杂数据类型</h3><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul>
<li>值类型：在存储时变量中存在的是值的本身，如：string，number，boolean，undefined，null</li>
<li>null返回的是一个空的对象object，如果忧国变量我们以后打算存储为对象，但没想好放啥，这个时候就给null</li>
<li>放到栈</li>
</ul>
<h4 id="复杂数据类型（引用类型）"><a href="#复杂数据类型（引用类型）" class="headerlink" title="复杂数据类型（引用类型）"></a>复杂数据类型（引用类型）</h4><ul>
<li>在存储变量中存储的仅仅是地址（引用）</li>
<li>通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等</li>
<li>放到堆</li>
</ul>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><h5 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h5><ul>
<li>文档：一个页面就是一个文档，DOM中使用document表示</li>
<li>元素：页面中的所有标签都是元素，DOM中使用element表示</li>
<li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示</li>
<li>DOM把以上元素都看成对象</li>
</ul>
<h4 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h4><h5 id="根据ID获取"><a href="#根据ID获取" class="headerlink" title="根据ID获取"></a>根据ID获取</h5><ul>
<li><p>```JavaScript</p>
<div id="time">2019-9-9</div>
<script>
    var timer =document.getElementById('time');
    console.log(timer);
    console.log(typeof timer);
    console.dir(timer);
</script>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line"></span><br><span class="line">  1. 因为我们文档页面从上往下加载，所以先得有标签，所以我们script写到标签的下面</span><br><span class="line">  2. get 获得element 元素by通过        驼峰命名法      getElementById</span><br><span class="line">  3. 参数id是大小写敏感的字符串</span><br><span class="line">  4. 返回的是一个元素对象</span><br><span class="line">  5. console.dir()打印我们返回的元素对象  更好的查看里面的属性和方法</span><br><span class="line"></span><br><span class="line">##### 根据标签名获取</span><br><span class="line"></span><br><span class="line">- 使用getElementsByTagName()方法可以返回带有指定标签名的**对象的集合**</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  document.getElementsByTagName(&#x27;标签名&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ol>
<li>因为得到的是一个对象的集合，以伪数组的形式存储的，所以我们想要操作里面的元素就需要遍历</li>
<li>得到元素对象是动态的</li>
<li>如果页面中只有一个此标签，返回的还是伪数组的形式</li>
<li>如果页面中没有此标签，返回的是空的伪数组的形式</li>
</ol>
</li>
</ul>
<h5 id="通过HTML5新增的方法获取-类名"><a href="#通过HTML5新增的方法获取-类名" class="headerlink" title="通过HTML5新增的方法获取(类名)"></a>通过HTML5新增的方法获取(类名)</h5><ul>
<li><p>```javascript<br>var dox1=document.getElementsByClassName(‘类名’);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 返回的也是伪数组</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  var firstBox=document.querySelector(&#x27;选择器&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回指定选择器的第一个元素对象</li>
<li>选择器必须要加符号</li>
</ul>
</li>
<li><p>```javascript<br>var AlltBox=document.querySelectorAll(‘选择器’);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 返回指定选择器的所有元素对象集合</span><br><span class="line">  - 选择器必须要加符号</span><br><span class="line"></span><br><span class="line">##### 获取特殊元素</span><br><span class="line"></span><br><span class="line">###### 获取body元素</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">doucument.body//返回body元素对象</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="获取html元素"><a href="#获取html元素" class="headerlink" title="获取html元素"></a>获取html元素</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doucument.doucumentElement<span class="comment">//返回html元素对象</span></span><br></pre></td></tr></table></figure>

<h5 id="window-getComputedStyle"><a href="#window-getComputedStyle" class="headerlink" title="window.getComputedStyle()"></a>window.getComputedStyle()</h5><ul>
<li><p><code>Window.getComputedStyle()</code>方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。 私有的CSS属性值可以通过对象提供的API或通过简单地使用CSS属性名称进行索引来访问。</p>
</li>
<li><p>语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="built_in">window</span>.getComputedStyle(element, [pseudoElt]);</span><br></pre></td></tr></table></figure></li>
<li><p>element</p>
<p>用于获取计算样式的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element"><code>Element</code></a>。</p>
</li>
<li><p>pseudoElt 可选</p>
<p>指定一个要匹配的伪元素的字符串。必须对普通元素省略（或<code>null</code>）。</p>
</li>
<li><p>返回的<code>style</code>是一个实时的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration"><code>CSSStyleDeclaration</code></a> 对象，当元素的样式更改时，它会自动更新本身。</p>
</li>
</ul>
<h4 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h4><p>触发—响应机制</p>
<h5 id="事件三元素"><a href="#事件三元素" class="headerlink" title="事件三元素"></a>事件三元素</h5><ol>
<li>事件源</li>
</ol>
<ul>
<li>事件被触发的对象</li>
</ul>
<ol start="2">
<li><p>事件类型</p>
<ul>
<li>如何触发 什么事件 比如：鼠标点击（onclick）还是鼠标经过还是键盘按下</li>
</ul>
</li>
<li><p>事件处理程序</p>
</li>
</ol>
<ul>
<li>通过一个函数赋值的方式完成</li>
</ul>
<ol start="4">
<li><p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;唐伯虎&lt;/button&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">var</span> btn = domcument.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    	alart(<span class="string">&#x27;点秋香&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="执行事件的步骤"><a href="#执行事件的步骤" class="headerlink" title="执行事件的步骤"></a>执行事件的步骤</h5><ol>
<li>获取事件源</li>
<li>注册事件（绑定事件）</li>
<li>添加事件处理程序（采用函数赋值形式）</li>
</ol>
<h4 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h4><h5 id="改变元素的内容"><a href="#改变元素的内容" class="headerlink" title="改变元素的内容"></a>改变元素的内容</h5><ul>
<li><p>从起始位置到终止位置的内容，但他去除一个html标签，同时空格和换行也会去掉</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.innerText</span><br></pre></td></tr></table></figure></li>
<li><p>起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.innerHTML</span><br></pre></td></tr></table></figure></li>
<li><p>区别：</p>
<ol>
<li><p>innerText不能识别HTML标签   分标准         去除空格和换行</p>
</li>
<li><p>innerHTML能识别HTML标签   W3C标准      保留空格和换行</p>
</li>
<li><p>这两个属性都是可读写的 可以获取元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.innerText);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h5 id="常用元素的属性操作"><a href="#常用元素的属性操作" class="headerlink" title="常用元素的属性操作"></a>常用元素的属性操作</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> innerText 、innerHTML   改变元素内容</span><br><span class="line"><span class="number">2.</span> src 、herf</span><br><span class="line"><span class="number">3.</span> id、alt、title</span><br></pre></td></tr></table></figure>

<h5 id="表单元素的属性操作"><a href="#表单元素的属性操作" class="headerlink" title="表单元素的属性操作"></a>表单元素的属性操作</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type、value、checked、selected、disabled</span><br></pre></td></tr></table></figure>

<h5 id="样式属性操作"><a href="#样式属性操作" class="headerlink" title="样式属性操作"></a>样式属性操作</h5><ul>
<li><p>我们可以通过JS修改元素的大小、颜色、位置等样式</p>
</li>
<li><p>```javascript<br>element.style       //行内样式操作<br>element.className   //类名样式操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 里面的样式采用驼峰命名法</span><br><span class="line"></span><br><span class="line">- Js修改style样式操作，产生的是行内样式，CSS权重比较高</span><br><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line"></span><br><span class="line">  1. 如果样式修改较多，可以采用操作类名方式更改元素样式</span><br><span class="line">  2. class因为是个保留字，因此使用className来操作元素类名属性</span><br><span class="line">  3. className会直接更改元素的类名，会覆盖原来的类名</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">          div &#123;</span><br><span class="line">              width: 100px;</span><br><span class="line">              height: 100px;</span><br><span class="line">              background-color: pink;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          .change &#123;</span><br><span class="line">              background-color: purple;</span><br><span class="line">              color: #fff;</span><br><span class="line">              font-size: 25px;</span><br><span class="line">              margin-top: 100px;</span><br><span class="line">          &#125;</span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">          // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用</span><br><span class="line">          var test = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">          test.onclick = function() &#123;</span><br><span class="line">              // this.style.backgroundColor = &#x27;purple&#x27;;</span><br><span class="line">              // this.style.color = &#x27;#fff&#x27;;</span><br><span class="line">              // this.style.fontSize = &#x27;25px&#x27;;</span><br><span class="line">              // this.style.marginTop = &#x27;100px&#x27;;</span><br><span class="line">              // 让我们当前元素的类名改为了 change</span><br><span class="line">  </span><br><span class="line">              // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况</span><br><span class="line">              // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器</span><br><span class="line">              // this.className = &#x27;change&#x27;;</span><br><span class="line">              this.className = &#x27;first change&#x27;;</span><br><span class="line">          &#125;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="排它思想"><a href="#排它思想" class="headerlink" title="排它思想"></a>排它思想</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;按钮<span class="number">1</span>&lt;/button&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 1. 获取所有按钮元素</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// btns得到的是伪数组  里面的每一个元素 btns[i]</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// (1) 我们先把所有的按钮背景颜色去掉  干掉所有人</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">             btns[i].style.backgroundColor = <span class="string">&#x27;&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// (2) 然后才让当前的元素背景颜色为pink 留下我自己</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;pink&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">     &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="自定义属性的操作"><a href="#自定义属性的操作" class="headerlink" title="自定义属性的操作"></a>自定义属性的操作</h5><ul>
<li><p>目的：是为了保存并使用数据，有些数据可以保存到页面而不用保存到数据库中</p>
</li>
<li><p>获取属性值</p>
<ol>
<li>element.属性         获取属性值</li>
<li>element.getAttribute(‘属性’);</li>
</ol>
</li>
<li><p>区别</p>
<ol>
<li>element.属性            获取内置属性值（元素本身自带的属性）</li>
<li>element.getAttribute(‘属性’);主要获得自定义的属性（标准）我们程序员自定义的属性    自定义属性如：index=”1”；</li>
</ol>
</li>
<li><p>设置属性值</p>
<ol>
<li>element.属性=’值’;         设置内置属性值</li>
<li>element.setAttribute(‘属性’,’值’);//主要针对于自定义属性，也可以设置其他的属性，class特殊，这里面就写class，不是className</li>
</ol>
</li>
<li><p>移除属性</p>
</li>
</ul>
<ol>
<li>element.removeAttribute(‘属性’);</li>
</ol>
<ul>
<li><p>H5自定义属性</p>
<ol>
<li><p>设置</p>
<ul>
<li><p>H5规定自定义属性data开头作为属性名并且赋值</p>
</li>
<li><p>比如<div data-index="1"></div>或者使用JS设置</p>
<p>element.setAttribute(‘data-index’,2)</p>
</li>
</ul>
</li>
<li><p>获取</p>
<ul>
<li>兼容性获取element.getAttribute(‘data-index’)</li>
<li>H5新增element.dataset.index或者element.dataset[‘index’]   ie11才开始支持</li>
<li>如果自定义属性里面有多个-链接的单词，我们获取的时候采取<em>驼峰命名法</em></li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><ul>
<li>利用DOM提供的方法逻辑性不强、繁琐</li>
<li>使用节点层级关系获取元素<ul>
<li>利用父子节点关系获取元素</li>
<li>逻辑性强、但兼容性稍差</li>
</ul>
</li>
</ul>
<h5 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h5><ul>
<li>一般的节点有三个基本属性<ul>
<li>节点类型：nodeType<ol>
<li>元素节点   1</li>
<li>属性节点    2</li>
<li>文本节点    3（文本节点包括文字、空格、换行等）</li>
</ol>
</li>
<li>节点名称：nodeName</li>
<li>节点值：nodeValue</li>
</ul>
</li>
</ul>
<h5 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h5><ul>
<li><p>父子兄层级关系</p>
<ol>
<li><p>父级节点</p>
<ul>
<li><p>```javascript<br>node.parentNode</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - parentNode属性可返回某节点的父节点，注意是最近的一个父节点</span><br><span class="line"></span><br><span class="line">   - 如果指定的节点没有父节点则返回null</span><br><span class="line"></span><br><span class="line">2. 子节点</span><br><span class="line"></span><br><span class="line">   ```javascript</span><br><span class="line">   1.parentNode.childNodes(标准)</span><br></pre></td></tr></table></figure></li>
<li><p>parentNode.childNodes返回包含指定节点的子节点的集合（元素节点、文本节点），该集合为及时更新的集合</p>
</li>
<li><p>换行是文本节点</p>
</li>
<li><p>如果想要获得里面的元素节点，就需要专门处理，所以我们一般不提倡使用childNodes</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;ul.childNodes.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ul.childNodes[i].nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//ul.childNodes[i]是元素节点</span></span><br><span class="line">        <span class="built_in">console</span>.log(ul.childNodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>parentNode.children(非标准)</span><br></pre></td></tr></table></figure>

<ul>
<li>parentNode.children是一个只读属性，返回所有的子元素节点，他只会返回子元素的节点。他只会返回子元素的节点，其余节点，其余节点不返回（这是我们重点掌握的）</li>
<li>虽然children是一个非标准，但得到了各个浏览器的支持，因此我门可以放心使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span>parentNode.firstChild</span><br></pre></td></tr></table></figure>

<ul>
<li>firstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span>parentNode.lastChild</span><br></pre></td></tr></table></figure>

<ul>
<li>lastChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5.</span>parentNode.firstElemenChild</span><br></pre></td></tr></table></figure>

<ul>
<li>firstElemenChild返回第一个子元素节点，找不到则返回null</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span>,parentNode.lastElemenChild</span><br></pre></td></tr></table></figure>

<ul>
<li>lastElemenChild返回第一个子元素节点，找不到则返回nul</li>
<li><strong>注意：这两个方法有兼容性问题，IE9以上才支持</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">7.</span> children[<span class="number">0</span>]     <span class="comment">//返回第一个元素</span></span><br><span class="line"><span class="number">8.</span> ol.chiildren[ol.children.length-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>实际写法，既没有兼容性问题还可以返回第一个和最后一个元素</li>
</ul>
</li>
<li><p>兄弟节点</p>
<ol>
<li><p>```javascript<br>node.nextSibling</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   nextSibling返回当前元素的下一个兄弟节点，找不到则返回null。同样，也包含所有节点（文本节点、元素节点等等）</span><br><span class="line"></span><br><span class="line">2. ```javascript</span><br><span class="line">   node.previousSibling</span><br></pre></td></tr></table></figure>

<p>previousSibling返回当前元素上一个兄弟节点，找不到则返回null。同样，也包含所有的节点（文本节点、元素节点等等）</p>
</li>
<li><p>```javascript<br>node.nextElementSibling</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   nextElementSibling返回当前元素下一个兄弟元素节点，找不到则返回null</span><br><span class="line"></span><br><span class="line">4. ```javascript</span><br><span class="line">   node.previouslementSibling</span><br></pre></td></tr></table></figure>

<p>previouslementSibling返回当前元素下一个兄弟元素节点，找不到则返回null</p>
<p><strong>注意：这3.4方法有兼容性问题，IE9以上才支持</strong></p>
</li>
<li><p>解决方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNextElementSibling</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = element;</span><br><span class="line">    <span class="keyword">while</span> (el = el.nextSibling) &#123;</span><br><span class="line">        <span class="keyword">if</span>(el.nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> el;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h5><ul>
<li><p>```javascript<br>document.createElement(‘tagName’)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- document.createElement()方法创建由tagName指定的HTML元素 。因为这些元素原来不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点</span><br><span class="line"></span><br><span class="line">##### 添加节点</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  node.appendChild(child)</span><br></pre></td></tr></table></figure>

<p>node.appendChild()方法将一个节点添加到指定父节点的子节点列表的末尾。类似于CSS里面的after伪元素</p>
</li>
<li><p>```javascript<br>node.insertBefore(child,指定元素)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  node.insertBefore(child,指定元素)    方法将一个节点添加到指定父节点的子节点列表的前面</span><br><span class="line"></span><br><span class="line">##### 删除节点</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  node.removeChild(child)</span><br></pre></td></tr></table></figure>

<p>node.removeChild()方法从DOM中删除一个子节点，返回删除的节点</p>
</li>
<li><p>```javascript</p>
<pre><code>// 1.获取元素
   var ul = document.querySelector(&#39;ul&#39;);
   var btn = document.querySelector(&#39;button&#39;);
   // 2. 删除元素  node.removeChild(child)
   // ul.removeChild(ul.children[0]);
   // 3. 点击按钮依次删除里面的孩子
     //小技巧:当li删除完之后禁用删除键    
   btn.onclick = function() &#123;
       if (ul.children.length == 0) &#123;
           this.disabled = true;//禁用删除键
       &#125; else &#123;
           ul.removeChild(ul.children[0]);
       &#125;
   &#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">##### for   in 复习</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line"> for(var k in obj) &#123;</span><br><span class="line">//     k 得到的是属性名</span><br><span class="line">//     obj[k] 得到是属性值</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="三种动态串创建元素的区别"><a href="#三种动态串创建元素的区别" class="headerlink" title="三种动态串创建元素的区别"></a>三种动态串创建元素的区别</h5><ul>
<li><p>document.write()</p>
<ul>
<li>创建元素 如果页面文档流加载完毕，在调用这句话会导致页面重绘</li>
</ul>
</li>
<li><p>element.innerHTNL</p>
<ul>
<li><p>innerHTML 是将内容写入某个DOM节点，不会导致页面全部重绘</p>
</li>
<li><p>innerHTML创建多个元素效率更高（不要拼接字符串，采用数组的形式拼接），结构稍微复杂</p>
</li>
<li><p>```javascript<br>function fn(){</p>
<pre><code>var array=[];
for(var i=0;i&lt;1000;i++)&#123;
    array.push(&#39;&lt;div&gt;&lt;/div&gt;&#39;);
&#125;
document.body.innerHTML=array.join(&#39;&#39;);
</code></pre>
<p>}          </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- document.createElement()</span><br><span class="line"></span><br><span class="line">  - createElement()创建多个元素效率稍微低低一点点，但结构更清晰</span><br><span class="line"></span><br><span class="line">#### DOM重点核心</span><br><span class="line"></span><br><span class="line">#### 事件高级导读</span><br><span class="line"></span><br><span class="line">##### 注册事件（绑定属性）</span><br><span class="line"></span><br><span class="line">###### 概述</span><br><span class="line"></span><br><span class="line">- 注册事件分为两种：传统方式和方法监听注册</span><br><span class="line"></span><br><span class="line">- | 传统注册方式                                                 | 方法监听注册方式                                 |</span><br><span class="line">  | ------------------------------------------------------------ | ------------------------------------------------ |</span><br><span class="line">  | 利用on开头的事件onclick                                      | W3C标准  推荐方式                                |</span><br><span class="line">  | &lt;button onclick=&#x27;alart(&quot;hi~&quot;)&#x27;&gt;&lt;/button&gt;                     | addEventListener()它是一个方法                   |</span><br><span class="line">  | btn.onclick=function()&#123;&#125;                                     | IE9之前的IE不支持此方法，可使用attackEvent()代替 |</span><br><span class="line">  | 特点：注册事件的唯一性                                       | 特点：同一个元素同一个事件可以注册多个监听器     |</span><br><span class="line">  | 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数 |                                                  |</span><br><span class="line"></span><br><span class="line">###### addEventListener事件监听方式</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  eventTarget.addEventListener(type,listener[,useCapturel])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>eventTarget.addEventListener()方法将指定的监听器注册到eventTarge(目标对象)上，当该对象触发指定的事件是，就会执行事件处理函数</p>
</li>
<li><p>该方法接受三个参数：</p>
<ol>
<li>type：事件类型字符串，比如click、mouseover，注意这里不要带on</li>
<li>listener：事件处理函数，事件发生时，会调用该监听函数</li>
<li>useCapture:可选参数，是一个布尔值，默认值是false，学完DOM事件流后，我们在进一步学习</li>
</ol>
</li>
<li><p>I9以上支持</p>
</li>
<li><p>事件处理函数，如果写函数名的话，不用加（）</p>
</li>
<li><p>useCapture:</p>
<ol>
<li>为 true 时：处于捕获阶段</li>
<li>为false 或者  省略  时：处于冒泡阶段</li>
</ol>
</li>
</ul>
<h6 id="attachEvent事件监听方式"><a href="#attachEvent事件监听方式" class="headerlink" title="attachEvent事件监听方式"></a>attachEvent事件监听方式</h6><ul>
<li><p>非标准，不建议使用，I9以前版本执行，了解知道</p>
</li>
<li><p>```javascript<br>eventTarget.attachEvent(eventNameWithOn,callback)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- eventTarget.attachEvent()方法将指定的监听器注册到eventTarge（目标对象）上，当该对象触发指定的事件时，指定的回调函数就会被执行</span><br><span class="line"></span><br><span class="line">- 该方法接受两个参数</span><br><span class="line"></span><br><span class="line">  - eventNameWithOn:事件类型字符串，比如onclick、onmouseover,这里要带on</span><br><span class="line">  - callback：事件处理函数，当目标触发事件的时回调函数被调用</span><br><span class="line"></span><br><span class="line">##### 删除事件</span><br><span class="line"></span><br><span class="line">- 传统注册方式</span><br><span class="line">  - eventTarget.onclick=null;</span><br><span class="line"></span><br><span class="line">- 方法监听注册方式</span><br><span class="line">  - eventTarget.removeEventListner(type,Listner[,useCapture]);</span><br><span class="line">  - eventTarget.datachEvent(eventNameWithOn,callback);</span><br><span class="line">    - eventNameWithOn这里要带on</span><br><span class="line"></span><br><span class="line">##### DOM事件流</span><br><span class="line"></span><br><span class="line">- 事件流描述的是从页面中接受事件的顺序</span><br><span class="line">- 事件发生时会在元素节点之间按照特定的顺序传播，这传播过程即DOM事件流</span><br><span class="line">- DOM事件流分为3个阶段</span><br><span class="line">  1. 捕获阶段</span><br><span class="line">  2. 当前目标阶段</span><br><span class="line">  3. 冒泡阶段</span><br><span class="line"></span><br><span class="line">- 事件冒泡：IE最早提出，事件开始时由具体的元素接受，然后逐级向上传播到DOM最顶层节点的过程</span><br><span class="line">  - onblur、onfocus、onmouseenter、onmouseleave是没有冒泡的</span><br><span class="line">- 事件捕获：网易最早提出，由DOM最顶层节点开始，然后逐级向下传播到具体的元素接受的过程</span><br><span class="line"></span><br><span class="line">##### 事件对象</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  div.onclick=function(event)&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  div.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>event 就是一个事件对象，写到我们我们监听函数的小括号里面 当形参来看</p>
</li>
<li><p>事件对象只有有了是事件才会存在，他是系统给我们自动创建的，不需要我们传递参数</p>
</li>
<li><p>事件对象是我们事件的一系列相关数据的集合跟集合相关的，比如鼠标点击里面就包含了鼠标的相关信息，</p>
</li>
<li><p>事件对象可以自己命名，比如event、evt、e</p>
</li>
<li><p>事件对象也有兼容性问题IE678通过window.event</p>
</li>
<li><p>兼容性处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//console.log(e);</span></span><br><span class="line">    <span class="comment">//console.log(window.event);</span></span><br><span class="line">    e=e||<span class="built_in">window</span>.event;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当我们注册事件时，event对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）</p>
</li>
<li><p>常用属性方法：</p>
<table>
<thead>
<tr>
<th>事件对象属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.target</td>
<td>返回触发事件的对象           标准</td>
</tr>
<tr>
<td>e.srcElement</td>
<td>返回触发事件的对象            非标准ie6·8使用</td>
</tr>
<tr>
<td>e.type</td>
<td>返回事件的类型，比如click、mouserover不带on</td>
</tr>
<tr>
<td>e.cancelBubble</td>
<td>该属性组织冒泡，非标准ie6·8使用</td>
</tr>
<tr>
<td>e.returnValue</td>
<td>该属性阻止默认事件（默认行为）非标准ie6·8使用比如不让链接跳转</td>
</tr>
<tr>
<td>e.preventDafault()</td>
<td>该方法阻止默认事件（默认行为）标准 不让链接跳转</td>
</tr>
<tr>
<td>e.stopPropagation()</td>
<td>阻止冒泡标准</td>
</tr>
</tbody></table>
<ul>
<li>e.target  返回<strong>触发</strong>事件的对象   this返回的是<strong>绑定</strong>事件的对象（元素）</li>
<li>了解：跟this有个非常相似的属性currentTarget   ie678不认识</li>
<li>return false也能组织默认行为，且没有兼容性问题，<strong>return后面的代码不执行了</strong>而且只限于传统注册方式</li>
</ul>
</li>
</ul>
<h5 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h5><h6 id="标准写法"><a href="#标准写法" class="headerlink" title="标准写法"></a>标准写法</h6><ul>
<li><p>利用事件对象里面的stopPropagation()方法   stop停止 Propagation传播</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">e.stopPropagation()</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="非标准写法"><a href="#非标准写法" class="headerlink" title="非标准写法"></a>非标准写法</h6><ul>
<li><p>IE6-8利用事件对象cancelBubble属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">e.cancelBubble = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>cancel  取消   bubble泡泡</p>
</li>
</ul>
<h6 id="兼容性解决方案"><a href="#兼容性解决方案" class="headerlink" title="兼容性解决方案"></a>兼容性解决方案</h6><ul>
<li><p>```javascript<br>if(e &amp;&amp; e.stopPropagation){</p>
<pre><code>e.stopPropagation();
</code></pre>
<p>}else{</p>
<pre><code>window.event.cancelBubble = true;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 事件委托</span><br><span class="line"></span><br><span class="line">- 事件委托</span><br><span class="line">  - 事件委托也称为事件代理，在jQuery里面被称为事件委派</span><br><span class="line"></span><br><span class="line">- 事件委托的原理</span><br><span class="line">  - 不是每个子节点单独设置事件监听器，而且事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</span><br><span class="line"></span><br><span class="line">#### 常用的鼠标事件</span><br><span class="line"></span><br><span class="line">| 鼠标事件    | 触发条件                                                   |</span><br><span class="line">| :---------- | ---------------------------------------------------------- |</span><br><span class="line">| onclick     | 鼠标点击左键触发                                           |</span><br><span class="line">| onmouseover | 鼠标经过触发                                               |</span><br><span class="line">| onmouseout  | 鼠标离开触发                                               |</span><br><span class="line">| onfocus     | 获得鼠标焦点触发                                           |</span><br><span class="line">| onblur      | 失去鼠标焦点触发                                           |</span><br><span class="line">| onmousemove | 鼠标移动触发                                               |</span><br><span class="line">| onmouseup   | 鼠标弹去触发                                               |</span><br><span class="line">| onmousedown | 鼠标按下触发                                               |</span><br><span class="line">| mouseleave  | 鼠标离开，不会冒泡，和mouseenter搭配                       |</span><br><span class="line">| mouseenter  | 当鼠标移动到元素上就触发，不过只经过自身盒子触发，不会冒泡 |</span><br><span class="line">| mouseover   | 鼠标经过自身盒子和子盒子会触发                             |</span><br><span class="line"></span><br><span class="line">- 禁止鼠标右键菜单</span><br><span class="line"></span><br><span class="line">  - contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</span><br><span class="line"></span><br><span class="line">  - ```javascript</span><br><span class="line">    document.addEventListener(&#x27;contextmenu&#x27;,function(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>禁止鼠标选中</p>
<ul>
<li><p>selectstart开始选中</p>
</li>
<li><p>```javascript<br>document.addEventListener(‘selectstart’,function(e){</p>
<pre><code>e.preventDefault();
</code></pre>
<p>})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###### 鼠标事件对象</span><br><span class="line"></span><br><span class="line">- event对象代表事件的状态，跟事件相关的一系列信息的集合，现阶段我们主要是用鼠标事件对象MouseEvent和键盘对象KeyboardEvent</span><br><span class="line"></span><br><span class="line">- | 鼠标事件对象 | 说明                                                      |</span><br><span class="line">  | ------------ | --------------------------------------------------------- |</span><br><span class="line">  | e.clientX    | 返回鼠标相对于浏览器窗口可视区的X坐标，不随页面滚动而变化 |</span><br><span class="line">  | e.clientY    | 返回鼠标相对于浏览器窗口可视区的Y坐标                     |</span><br><span class="line">  | e.pageX      | 返回鼠标相对于文档页面的X坐标  IE9+支持                   |</span><br><span class="line">  | e.pageY      | 返回鼠标相对于文档页面的Y坐标  IE9+支持                   |</span><br><span class="line">  | e.screenX    | 返回鼠标相对于电脑屏幕的X坐标                             |</span><br><span class="line">  | e.screenY    | 返回鼠标相对于电脑屏幕的Y坐标                             |</span><br><span class="line"></span><br><span class="line">#### 常用的键盘事件</span><br><span class="line"></span><br><span class="line">| 键盘事件   | 触发条件                                                     |</span><br><span class="line">| ---------- | ------------------------------------------------------------ |</span><br><span class="line">| onkeyup    | 某个键盘按键被松开时触发                                     |</span><br><span class="line">| onkeydown  | 某个键盘按键被按下时触发                                     |</span><br><span class="line">| onkeypress | 某个键盘按键被按下时触发，但是它不识别功能键，比如ctrl shift 箭头等 |</span><br><span class="line"></span><br><span class="line">-  注意：三个事件的执行顺序是onkeydown----onkeypress----onkeyup</span><br><span class="line">-  keydown：当用户按下键盘上的任意键时触发，如果按住不放的话，会重复触发此事件；</span><br><span class="line">-  keypress：当用户按下键盘上的**字符键**时触发，如果按住不让的话，会重复触发此事件；</span><br><span class="line">-  keyup：当用户**释放**键盘上的字符键时触发。</span><br><span class="line"></span><br><span class="line">##### 键盘事件对象</span><br><span class="line"></span><br><span class="line">| 键盘事件对象属性 | 说明              |</span><br><span class="line">| ---------------- | ----------------- |</span><br><span class="line">| keyCode          | 返回该键的ASCll值 |</span><br><span class="line"></span><br><span class="line">- 我们的keyup和keydown事件不区分大小写  a和 A得到的都是65</span><br><span class="line">- 我们的keypress事件区分大小写 </span><br><span class="line">- 利用keyCode返回的ASCll码判断按下的是那个键</span><br><span class="line">- 属性：</span><br><span class="line">  - element.altKey    element.strlKey    element.shiftKey</span><br><span class="line"></span><br><span class="line">### BOM</span><br><span class="line"></span><br><span class="line">#### BOM概述</span><br><span class="line"></span><br><span class="line">##### 什么是BOM</span><br><span class="line"></span><br><span class="line">- BOM即浏览器对象模型，他提供了独立于内容而与浏览器窗口进行交会的对象，其核心对象是window</span><br><span class="line">- BOM由一系列相关的对象有关，并且每个对象都提供了而很多的方法和属性</span><br><span class="line"></span><br><span class="line">- BOM是将浏览器看作一个对象来看待的</span><br><span class="line">- BOM由个浏览器厂商在各自浏览器上定义的，兼容性较差</span><br><span class="line"></span><br><span class="line">##### BOM的构成</span><br><span class="line"></span><br><span class="line">- window对象是浏览器的顶级窗口，它具有双重角色</span><br><span class="line">  1. 他是JS访问浏览器窗口的一个接口</span><br><span class="line">  2. 他是一个全局对象，定义在全局作用域中的变量，函数会变成window对象的属性和方法</span><br><span class="line">  3. 调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alart()、prompt()等</span><br><span class="line">  4. 注意：window下一个特殊属性是window.name</span><br><span class="line"></span><br><span class="line">#### window对象的常见事件</span><br><span class="line"></span><br><span class="line">##### 窗口加载事件</span><br><span class="line"></span><br><span class="line">###### load</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  window.onload = function()&#123;&#125;</span><br><span class="line">  //或者</span><br><span class="line">  window.addEventListener(&quot;load&quot;，function()&#123;&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>window.onload是窗口（页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像、脚本文档、CSS文件等），就调用的处理函数</p>
</li>
<li><p>注意：</p>
<ol>
<li>有了window.onload就可以吧JS代码写到页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数</li>
<li>window.onload传统注册事件的方式只能写一次，如果有多个，以最后一个为准</li>
<li>如果使用addEventListener，则没有限制</li>
</ol>
</li>
</ul>
<h6 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h6><ul>
<li><p>```javascript<br>domcument.addEventListener(‘DOMContentLoaded’,function(){})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等 IE以上才支持</span><br><span class="line"></span><br><span class="line">- 如果页面的图片很多的话，从用户访问到onload触发可能需要较长的时间，交互效果就不能实现，必然影响用户体验，此时用DOMContentLoaded事件比较合适</span><br><span class="line"></span><br><span class="line">- 区别：</span><br><span class="line"></span><br><span class="line">  - load是等页面内容全部加载完毕，再去执行处理函数</span><br><span class="line">  - DOMContentLoaded是DOM加载完毕，不包含图片、falsh css等就可以执行</span><br><span class="line"></span><br><span class="line">##### 调整窗口大小事件</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  window.onresize = function()&#123;&#125;;</span><br><span class="line">  window.addEventListener(&#x27;resize&#x27;,function()&#123;&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>window.onresize是调整窗口大小加载事件，当触发时就调用的处理函数</p>
</li>
<li><p>注意：</p>
<ol>
<li>只要窗口大小像素发生变化，就会触发整个事件</li>
<li>我们经常利用这个事件完成响应式布局，window.innerWidth当前屏幕的宽度</li>
</ol>
</li>
</ul>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><h5 id="两种定时器"><a href="#两种定时器" class="headerlink" title="两种定时器"></a>两种定时器</h5><ol>
<li><p>setTimeout()    </p>
<ul>
<li>```javascript<br>window.setTimeout(调用函数,[延迟的毫秒数]);         <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- setTimeout()方法用于设置一个定时器，该定时器在**定时器到期后执行调用函数**</span><br><span class="line"></span><br><span class="line">- 调用函数可以直接写函数也可以写函数名</span><br><span class="line"></span><br><span class="line">- 这个调用函数，需要等待时间，时间到了才会去调用这个函数，因此称为**回调函数**。简单理解，回调就是回头调用的意思，下一件干完，再回头调用这个函数</span><br><span class="line"></span><br><span class="line">- 延迟的毫秒数省略默认是0，如果写，必须是毫秒</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  function callback()&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  setTimeout(callback,3000);</span><br><span class="line">   setTimeout(&#x27;callback()&#x27;,3000);//不提倡</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>停止setTimeout()定时器</p>
<ul>
<li><p>window.clearTimeout(timeoutID)</p>
</li>
<li><p>```javascript<br><button>点击停止</button></p>
<pre><code>&lt;script&gt;
    var btn = document.querySelector(&#39;button&#39;);
    var timer = setTimeout(function() &#123;
        console.log(&#39;爆炸了&#39;);
    &#125;, 3000);
    btn.addEventListener(&#39;click&#39;, function() &#123;
        clearTimeout(timer);
    &#125;)
&lt;/script&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. setInterval()定时器</span><br><span class="line"></span><br><span class="line">   - ```javascript</span><br><span class="line">     window.setlnterval(回调函数,[间隔的毫秒数]);</span><br></pre></td></tr></table></figure></li>
<li><p>setInterval()方法<strong>重复调用一个函数</strong>，每隔一个函数，每隔这个时间，就去调用一次回调函数</p>
</li>
<li><p>注意：</p>
<ol>
<li>window可以省略</li>
<li>这个调用函数可以直接写函数，或者写函数名或者采取字符串’函数名()’三种形式</li>
<li>间隔的毫秒数默认为0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数</li>
<li>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符</li>
</ol>
</li>
</ul>
</li>
<li><p>停止setInterval()定时器</p>
<ul>
<li>```javascript<br>window.clearInterval(intervalID);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - clearInterval()方法取消了先前通过调用setInterval()建立的定时器</span><br><span class="line"></span><br><span class="line">   - 注意：</span><br><span class="line"></span><br><span class="line">     1. window可以省略</span><br><span class="line">     2. 里面的参数就是定时器的标识符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### this指向问题</span><br><span class="line"></span><br><span class="line">- this的指向在函数定义的时候是确定不了的，只要在函数执行的时候才能确定this到底指向谁，一般情况this的最终指向的是那个调用它的对象</span><br><span class="line">- 在全局作用域或者普通函数中this的指向全局对象window（注意定时器里面的this指向window）</span><br><span class="line">- 方法调用中谁调用this指向谁</span><br><span class="line">- 构造函数中this指向构造函数的实例</span><br><span class="line">- 定时器里面的this指向window</span><br><span class="line"></span><br><span class="line">#### JS执行机制</span><br><span class="line"></span><br><span class="line">##### JS是单线程</span><br><span class="line"></span><br><span class="line">- JS最大的特点是单线程，同一时间只能做一件事</span><br><span class="line">- 若JS执行时间过长，这样就会造成页面渲染不连贯，导致页面渲染加载阻塞的感觉</span><br><span class="line"></span><br><span class="line">##### 同步和异步</span><br><span class="line"></span><br><span class="line">为了解决这个问题，利用多核CPU的计算能力</span><br><span class="line"></span><br><span class="line">###### 同步</span><br><span class="line"></span><br><span class="line">前一个任务结束后再去执行后一个任务，程序的执行顺序于任务排列顺序是一致的、同步的，比如做饭的同步做法：我们要烧水做饭，等水开了（十分种后），再去切菜、炒菜</span><br><span class="line"></span><br><span class="line">###### 异步</span><br><span class="line"></span><br><span class="line">你在做一件事时，因为这件事会花费很长时间，在做这件事的同时，你还可以去处理其他事，比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜</span><br><span class="line"></span><br><span class="line">###### 本质区别</span><br><span class="line"></span><br><span class="line">这条流水线上各个流程的执行顺序不同</span><br><span class="line"></span><br><span class="line">###### 同步任务</span><br><span class="line"></span><br><span class="line">同步任务都在主线程上执行，形成一个执行栈</span><br><span class="line"></span><br><span class="line">###### 异步任务</span><br><span class="line"></span><br><span class="line">- JS异步是通过回调函数实现的</span><br><span class="line">- 一般而言，异步任务有以下三种类型</span><br><span class="line">  1. 普通事件，如click、resize</span><br><span class="line">  2. 资源加载，如load、error</span><br><span class="line">  3. 定时器，包括setInterval、setTimeout</span><br><span class="line"></span><br><span class="line">- 异步任务相关回调函数添加到任务列表中（任务队列也称为消息队列）</span><br><span class="line"></span><br><span class="line">##### JS执行机制</span><br><span class="line"></span><br><span class="line">- 先执行执行栈中的同步任务</span><br><span class="line">- 异步任务（回调函数）放在任务队列</span><br><span class="line">- 一旦执行栈中的所有同步任务执行完毕，系统会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</span><br><span class="line"></span><br><span class="line">#### open对象</span><br><span class="line"></span><br><span class="line">- window.open()    &amp;open()</span><br><span class="line"></span><br><span class="line">- 内容：</span><br><span class="line"></span><br><span class="line">  1. 加载URL</span><br><span class="line">  2. 窗口的名称或者窗口的目标</span><br><span class="line">  3. 一串具有特殊意义的字符串</span><br><span class="line"></span><br><span class="line">- 注：</span><br><span class="line"></span><br><span class="line">  - 如果只有第一个参数，调用open方法会打开新窗口，加载url</span><br><span class="line"></span><br><span class="line">  - 第二个参数，是给打开的新窗口起一个名字然后以后，再去加载url</span><br><span class="line"></span><br><span class="line">  - 第三个参数是字符串</span><br><span class="line"></span><br><span class="line">    - | 名称   | 值   | 说明                      |</span><br><span class="line">      | ------ | ---- | ------------------------- |</span><br><span class="line">      | width  | 数值 | 新窗口的宽度，不能小于100 |</span><br><span class="line">      | height | 数值 | 新窗口的高度，不能小于100 |</span><br><span class="line">      | top    | 数值 | 新窗口的Y坐标，不能是负值 |</span><br><span class="line">      | left   | 数值 | 新窗口的X坐标，不能是负值 |</span><br><span class="line"></span><br><span class="line">    - 设置当前打开窗口的参数</span><br><span class="line"></span><br><span class="line">  - opener是打开当前窗口的父窗口的window对象(**IE不支持**)</span><br><span class="line"></span><br><span class="line">#### location对象</span><br><span class="line"></span><br><span class="line">window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL。因为这个属性返回的是一个对象，我们将这个属性也成为location对象</span><br><span class="line"></span><br><span class="line">###### URL</span><br><span class="line"></span><br><span class="line">- 统一资源定位符是互联网上标准资源的地址。互联网上的每个文件都有唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它</span><br><span class="line"></span><br><span class="line">- 一般语法格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
protocol://host[:post]/path/[?quary]#fragmrnt<br><a href="http://www.itcast.cn/index.html?name=andy&amp;age=18#link">http://www.itcast.cn/index.html?name=andy&amp;age=18#link</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| 组成     | 说明                                                         |</span><br><span class="line">| -------- | ------------------------------------------------------------ |</span><br><span class="line">| protocol | 通信协议 常用的http,ftp,maito等                              |</span><br><span class="line">| host     | 主机（域名）www.itheima.com                                  |</span><br><span class="line">| port     | 端口号 可选，省略时使用方案的默认接口，如http的默认端口为80  |</span><br><span class="line">| path     | 路径 由 零或多个&#x27;/&#x27;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址 |</span><br><span class="line">| query    | 参数 以键值对的形式，通过&amp;符号分隔开                         |</span><br><span class="line">| fragment | 片段  #后面的内容常用于链接 锚点                             |</span><br><span class="line"></span><br><span class="line">###### location对象属性</span><br><span class="line"></span><br><span class="line">| location对象属性    | 返回值                               |</span><br><span class="line">| ------------------- | ------------------------------------ |</span><br><span class="line">| location.herf       | 获取或着设置整个URL                  |</span><br><span class="line">| location.host       | 返回主机（域名）www.itheima.com      |</span><br><span class="line">| location.port       | 返回端口号 如果未写返回空字符串      |</span><br><span class="line">| falocation.pathname | 返回路径                             |</span><br><span class="line">| location.search     | 返回参数                             |</span><br><span class="line">| location.hash       | 返回片段 #后面的内容 常见于链接 锚点 |</span><br><span class="line"></span><br><span class="line">- 给location.href赋值，可以跳转到其他页面</span><br><span class="line">- window.location==window.document.location</span><br><span class="line"></span><br><span class="line">###### location常见方法</span><br><span class="line"></span><br><span class="line">- | location对象方法   | 返回值                                                       |</span><br><span class="line">  | ------------------ | ------------------------------------------------------------ |</span><br><span class="line">  | location.assign()  | 跟href一样，可以跳转页面（也称重定向页面）                   |</span><br><span class="line">  | location.replace() | 替换当前页面，因为不记录历史，所以不能后退页面               |</span><br><span class="line">  | location.reload()  | 重新加载页面，相当于刷新按钮或者f5,如果参数为true强制刷新ctrl+f5 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### nevigator对象</span><br><span class="line"></span><br><span class="line">- navigator对象吧包含有关浏览器的信息，他有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值</span><br><span class="line"></span><br><span class="line">- 下面前端代码可以判断用户那个终端打开页面，实现跳转</span><br><span class="line"></span><br></pre></td></tr></table></figure>
if((navigator.userAgent.match(/(phone|pad|pod|iphone|ipod|ios|ipad|Android|Mobile|BlackBeery|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|Webos|Symbian|window Phone)/i))) {<br> window.location.href = “”;//手机<br>}else {<br> window.location.href = “”;//电脑<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### history对象</span><br><span class="line"></span><br><span class="line">- window对象给我们提供了一个history对象，与浏览器历史记录进行交互，该对象包含用户（在浏览器窗口中）访问过的URL</span><br><span class="line"></span><br><span class="line">- | history对象方法 | 作用                                                    |</span><br><span class="line">  | --------------- | ------------------------------------------------------- |</span><br><span class="line">  | back()          | 可以后退功能                                            |</span><br><span class="line">  | forward()       | 前进功能                                                |</span><br><span class="line">  | go(参数)        | 前进后退功能 参数如果是1前进1个页面如果是-1后退一个页面 |</span><br><span class="line"></span><br><span class="line">#### search处理</span><br><span class="line"></span><br><span class="line">- search.indexOf(key)//找不到目标返回值就是-1</span><br><span class="line"></span><br><span class="line">### PC端网络特效</span><br><span class="line"></span><br><span class="line">#### 元素偏移量offset系列</span><br><span class="line"></span><br><span class="line">##### offset概述</span><br><span class="line"></span><br><span class="line">- offset翻译过来就是偏移量，我们使用offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等</span><br><span class="line"></span><br><span class="line">  - 获得元素距离带有定位父元素的位置</span><br><span class="line">  - 获得元素自身大小（宽度高度）</span><br><span class="line">  - 注意：返回的数值不带单位</span><br><span class="line"></span><br><span class="line">- offset系列常用属性：</span><br><span class="line"></span><br><span class="line">  | offset系列属性       | 作用                                                         |</span><br><span class="line">  | -------------------- | ------------------------------------------------------------ |</span><br><span class="line">  | element.offsetParent | 返回作为该元素带有定位的父级元素 如果父级元素都没有定位则返回body |</span><br><span class="line">  | element.offsetTop    | 返回元素相对带有定位父元素上方的偏移                         |</span><br><span class="line">  | element.offsetLeft   | 返回元素相对带有定位元素左边框的偏移                         |</span><br><span class="line">  | element.offsetWidth  | 返回自身包括padding、边框、内容区的高度，返回数值不带单位    |</span><br><span class="line">  | element.offsetHeight | 返回自身包括padding、边框、内容区的高度，返回数值不带单位    |</span><br><span class="line"></span><br><span class="line">##### offset与style区别</span><br><span class="line"></span><br><span class="line">- offset</span><br><span class="line">  - offset可以得到任意样式表中的样式值</span><br><span class="line">  - offset系列获得的数值是没有单位的</span><br><span class="line">  - offsetWidth包含padding+border+width</span><br><span class="line">  - offsetWidthde等属性是只读属性，只能获取不能赋值</span><br><span class="line">  - 所以，我们想要获取元素大小位置，用offset更合适</span><br><span class="line"></span><br><span class="line">- style</span><br><span class="line">  - style只能得到行内样式表中的样式值</span><br><span class="line">  - style.width获得的是带单位的字符串</span><br><span class="line">  - style.widyh获得不包含padding和border的值</span><br><span class="line">  - style.width是可读写属性，可以获取也可以赋值</span><br><span class="line">  - 所以，我们想要给元素更改值，则需要用style改变</span><br><span class="line"></span><br><span class="line">#### 元素可视区client系列</span><br><span class="line"></span><br><span class="line">- client翻译过来就是客户端，我们使用client系列的相关信息，通过client系列的相关属性可以动态的得到该元素的边框大小，元素大小等。</span><br><span class="line"></span><br><span class="line">- | client系列属性       | 作用                                                         |</span><br><span class="line">  | -------------------- | ------------------------------------------------------------ |</span><br><span class="line">  | element.clientTop    | 返回元素的上边框的大小                                       |</span><br><span class="line">  | element.clientLeft   | 返回元素左边框的的大小                                       |</span><br><span class="line">  | element.clientWidth  | 返回自身包括padding，内容区的宽度，不含边框，返回数值不带单位 |</span><br><span class="line">  | element.clientHeight | 返回自身包括padding，内容区的高度，不含边框，返回数值不带单位 |</span><br><span class="line"></span><br><span class="line">##### 立即执行函数</span><br><span class="line"></span><br><span class="line">- 定义：不需要带哦有，立马能够自己执行的函数</span><br><span class="line"></span><br><span class="line">- 写法：(function () &#123;&#125; ) ()     或者       （function () &#123;&#125; () );</span><br><span class="line">- 主要作用：创建一个独立的作用域0，避免命名冲突问题</span><br><span class="line">- 第二个小括号可以看作是调用函数</span><br><span class="line">- 也可以写函数名</span><br><span class="line"></span><br><span class="line">#### 元素滚动sroll系列</span><br><span class="line"></span><br><span class="line">##### 元素sroll系列属性</span><br><span class="line"></span><br><span class="line">- sroll翻译过来就是滚动的，我们使用sroll系列的相关属性可以动态的得到该元素的大小，滚动距离等</span><br><span class="line"></span><br><span class="line">- | sroll系列属性       | 作用                                           |</span><br><span class="line">  | ------------------- | ---------------------------------------------- |</span><br><span class="line">  | element.srollTop    | 返回被卷去的上侧距离，返回数值不带单位         |</span><br><span class="line">  | element.srollLeft   | 返回被卷去的左侧距离，返回数值不带单位         |</span><br><span class="line">  | element.srollWidth  | 返回自身的实际宽度，不含边框，返回数值不带单位 |</span><br><span class="line">  | element.srollHeight | 返回自身的实际高度，不含边框，返回数值不带单位 |</span><br><span class="line"></span><br><span class="line">##### 页面被卷去 的头部兼容性解决方案</span><br><span class="line"></span><br><span class="line">- 需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有以下几种写法</span><br><span class="line"></span><br><span class="line">  1. 声明了DTD，使用document.documentElement.scrollTop</span><br><span class="line">  2. 未声明DTD，使用document.body.srollTop</span><br><span class="line">  3. 新方法window.pageYOffset和window.pageXOffset,IE9开始 支持</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  function getScroll()&#123;</span><br><span class="line">  	return &#123;       				left:window.pageXOffset||document.documentElement.scrollLeft||document.body.srollLeft||0,</span><br><span class="line">  top:window.pageYOffset||document.documentElement.scrollTop||document.body.srollTop||0</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  //使用的时候 </span><br><span class="line">  getSroll().left</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="三大系类总结"><a href="#三大系类总结" class="headerlink" title="三大系类总结"></a>三大系类总结</h4><table>
<thead>
<tr>
<th>三大系列大小对比</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.offsetWidth</td>
<td>返回自身包括padding，边框，内容区的高度，返回数值不带单位</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回自身包含padding，内容区的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.srollWidth</td>
<td>返回自身实际的宽度，不含边框，返回数值不带单位</td>
</tr>
</tbody></table>
<ul>
<li>主要用法<ol>
<li>offset系列经常用于获得元素位置 offsetLeft、ofFsetTop</li>
<li>client经常用于获取元素大小clientWidth、clientHeight</li>
<li>scroll经常用于获取滚动距离scrollTop、scrollLeft</li>
<li>注意页面滚动距离通过window.pageXOffset获得</li>
</ol>
</li>
</ul>
<h4 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h4><h5 id="dpr-物理像素比"><a href="#dpr-物理像素比" class="headerlink" title="dpr  物理像素比"></a>dpr  物理像素比</h5><ul>
<li>var dpr=window.devicePixelRatio ||  1</li>
<li>如果有自身的像素比，如有就用本身的，没有就用1</li>
<li>PC端是1</li>
<li>iphone678是2</li>
</ul>
<h5 id="pageshow事件"><a href="#pageshow事件" class="headerlink" title="pageshow事件"></a>pageshow事件</h5><ul>
<li><p>我们重新加载页面触发的事件</p>
</li>
<li><p>e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要重新计算一下rem的大小</p>
</li>
</ul>
<h4 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h4><h5 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h5><ul>
<li><p>核心原理：通过定时器setInterval()不断移动盒子的位置</p>
</li>
<li><p>```javascript<br>//动画函数的封装<br>// 简单动画函数封装obj目标对象 target 目标位置<br>function animate(obj, target) {</p>
<pre><code>//给不同元素指定了不同的定时器
        obj.timer = setInterval(function() &#123;
            if (obj.offsetLeft &gt;= target) &#123;
                // 停止动画 本质是停止定时器
                clearInterval(obj.timer);
            &#125;
            obj.style.left = obj.offsetLeft + 1 + &#39;px&#39;;

        &#125;, 30);
    &#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 缓动效果原理</span><br><span class="line"></span><br><span class="line">- 缓动动画就是让元素运动的速度有所变化，最常见的就是让速度慢慢停下来</span><br><span class="line"></span><br><span class="line">- 思路：</span><br><span class="line"></span><br><span class="line">  1. 让盒子每次移动的距离慢慢减小，速度就会慢慢落下来</span><br><span class="line">  2. 核心算法：(目标值-现在的位置)/10 作为每次移动的距离步长</span><br><span class="line">  3. 停止条件就是：让盒子当前位置等于目标位置就停止定时器</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  function animate(obj, target) &#123;</span><br><span class="line">              // 先清除以前的定时器，只保留当前的一个定时器执行</span><br><span class="line">              clearInterval(obj.timer);</span><br><span class="line">              obj.timer = setInterval(function() &#123;</span><br><span class="line">                  // 步长值写到定时器的里面</span><br><span class="line">                  // 把我们步长值改为整数 不要出现小数的问题</span><br><span class="line">                  // var step = Math.ceil((target - obj.offsetLeft) / 10);</span><br><span class="line">                  var step = (target - obj.offsetLeft) / 10;</span><br><span class="line">                  step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);</span><br><span class="line">                  if (obj.offsetLeft == target) &#123;</span><br><span class="line">                      // 停止动画 本质是停止定时器</span><br><span class="line">                      clearInterval(obj.timer);</span><br><span class="line">                  &#125;</span><br><span class="line">                  // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10</span><br><span class="line">                  obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;</span><br><span class="line">  </span><br><span class="line">              &#125;, 15);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="动画函数添加回调函数"><a href="#动画函数添加回调函数" class="headerlink" title="动画函数添加回调函数"></a>动画函数添加回调函数</h5><ul>
<li>回调函数原理：函数可以作为一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完毕之后，再执行传进去的这个函数，这个过程称为<strong>回调</strong>。</li>
<li>写到定时器结束里面</li>
</ul>
<h5 id="节流阀"><a href="#节流阀" class="headerlink" title="节流阀"></a>节流阀</h5><ul>
<li><p>防止轮播图按钮连续点击造成播放太快</p>
</li>
<li><p>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让世界无法连续触发</p>
</li>
<li><p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数</p>
</li>
<li><p>开始设置一个变量var flag = true;</p>
</li>
<li><p>if(flag){</p>
<p>​    flag=false;</p>
<p>​    do something;</p>
<p>}//关闭水龙头</p>
</li>
<li><p>利用回调函数 动画执行完毕，flag = true 打卡水龙头</p>
</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><ul>
<li>HTTP：超文本传输协议，用于从web服务器传输超文本到本地浏览器的传输协议，他是一个无状态的协议</li>
</ul>
<h4 id="cookie概述"><a href="#cookie概述" class="headerlink" title="cookie概述"></a>cookie概述</h4><ul>
<li><p>cookie是指缓存在本地客户端的数据</p>
</li>
<li><p>cookie一般储存100多条数据</p>
</li>
<li><p>```javascript</p>
<pre><code>//查询cookie
   console.log(document.cookie);
   //设置cookie
   document.cookie = &quot;username=honny&quot;;
   //设置存储时间
   var oDate = new Date();
   oDate.setDate(oDate.getDate() + 3);
   document.cookie = &quot;username=honny;expires=&quot; + oDate;
   //修改cookie
   document.cookie = &quot;username=honny&quot;;
   document.cookie = &quot;username=honny1&quot;;
   //删除cookie
   var oDate = new Date();
   document.cookie = &quot;username=honny;expires=&quot; + oDate;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### cookie函数的封装</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  //新建cookie</span><br><span class="line">  function setCookie(name, value, day) &#123;</span><br><span class="line">              var oDate = new Date();</span><br><span class="line">              oDate.setDate(oDate.getDate() + day);</span><br><span class="line">              document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + oDate;</span><br><span class="line">          &#125;</span><br><span class="line">          setCookie(&quot;name1&quot;, &quot;honney1&quot;, 1);</span><br><span class="line">          setCookie(&quot;name2&quot;, &quot;honney2&quot;, 1);</span><br><span class="line">  </span><br><span class="line">          console.log(document.cookie);</span><br><span class="line">  //获取cookie</span><br><span class="line">          function getCookie(name) &#123;</span><br><span class="line">              var str = document.cookie;</span><br><span class="line">              var arr = str.split(&quot;; &quot;);</span><br><span class="line">              for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                  var arr1 = arr[i].split(&quot;=&quot;);</span><br><span class="line">                  if (arr1[0] == name) &#123;</span><br><span class="line">                      return arr1[1];</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          console.log(getCookie(&quot;name2&quot;));</span><br><span class="line">  //消除cookie</span><br><span class="line">          function removeCookie(name) &#123;</span><br><span class="line">              setCookie(name, 1, -1);</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          removeCookie(&quot;name1&quot;);</span><br><span class="line">          console.log(getCookie(&quot;name1&quot;));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>正则表达式是由普通字符及特殊字符组成的对字符串进行过滤的逻辑公式</li>
</ul>
<h4 id="创建方式-1"><a href="#创建方式-1" class="headerlink" title="创建方式"></a>创建方式</h4><ul>
<li><p>字面量的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abc/</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> flag = reg.test(str);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>test方法：正则表达式的方法，用于检测字符串是否含有复合规则的子串，有返回true，没返回false</p>
</li>
<li><p>exec方法：正则表达式的方法，将匹配成功的内容放到数组里，如果没有在则返回null</p>
</li>
<li><p>match方法：字符串方法 str.match(reg);</p>
</li>
<li><p>search方法：用于查找符合规则的子串的位置只返回第一个匹配的位置</p>
</li>
<li><p>split方法：以。。。分隔</p>
</li>
<li><p>replace方法：用第二个字符串替换第一个</p>
</li>
<li><p>修饰符g   i</p>
<ul>
<li>g表示全局匹配</li>
<li>i表示忽略大小写</li>
</ul>
</li>
</ul>
</li>
<li><p>特殊字符</p>
<ul>
<li><p>.代表除了换行符之外的所有单个字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/g..gle/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;googleg--gle&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(rest.test(str));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br></pre></td></tr></table></figure></li>
<li><p>*重复多次匹配，匹配任意次（0-n）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/g*gle/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;ggggle&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br></pre></td></tr></table></figure></li>
<li><p>+至少有一次重复匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/g+gle/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;ggle&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str));</span><br></pre></td></tr></table></figure></li>
<li><p>? 进行0或者1次匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/g?gle/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;ggle&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str));</span><br></pre></td></tr></table></figure></li>
<li><p>[]表示可以出现的范围[0-9]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123m4&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str));</span><br></pre></td></tr></table></figure></li>
<li><p>\w数字字母下划线等同于[0-9||a-z||A-Z||_ ]  \W非数字字母下划线</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w+/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc13&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str),str.match(reg));</span><br></pre></td></tr></table></figure></li>
<li><p>\d表示数字[0-9]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;12345abc&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str),str.match(reg));</span><br></pre></td></tr></table></figure></li>
<li><p>\s 匹配空格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\s+/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;good good   study&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>{m,n}至少匹配m次，至多匹配n次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/go&#123;3,6&#125;gle/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;gooogle&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str));</span><br></pre></td></tr></table></figure></li>
<li><p>// /^ 匹配开始$/匹配结尾</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^g.+g$/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;gooogle&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str));</span><br></pre></td></tr></table></figure></li>
<li><p>|   或</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/google|baidu|bing|yahoo/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str));</span><br></pre></td></tr></table></figure></li>
<li><p>() 分组 将内容作为一个整体进行匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(g.+gle)&#123;4,6&#125;/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;googleaaagooglegooglegooglegoogle&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str),str.match(reg));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);<span class="comment">//获取里面的分组内容</span></span><br></pre></td></tr></table></figure></li>
<li><p>$1 $2分组中的第一个元素和第二个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(.*)\s(.*)/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;taobao baidu&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg,<span class="string">&quot;$2 $1&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="ES6基础语法"><a href="#ES6基础语法" class="headerlink" title="ES6基础语法"></a>ES6基础语法</h3><h4 id="let的使用"><a href="#let的使用" class="headerlink" title="let的使用"></a>let的使用</h4><ul>
<li>用于声明变量。他的用法类似于var，但是声明的变量，只在let命令所在的代码块内有效</li>
<li>存在块级作用域{}</li>
<li>不存在声明提升</li>
<li>不允许重复声明（包括普通变量和函数参数）</li>
</ul>
<h4 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h4><ul>
<li>用于声明常量，不要试图改变常量的值，其他语法参照let</li>
</ul>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><ul>
<li><p>按照一定模式，从数组和对象中提取值，对变量进行赋值</p>
</li>
<li><p>数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>默认赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[a,b=<span class="number">2</span>]=[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> c;</span><br><span class="line">[a=<span class="number">3</span>]=[c];<span class="comment">//不会覆盖2</span></span><br></pre></td></tr></table></figure></li>
<li><p>对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a,b&#125;=&#123;<span class="attr">a</span>:<span class="string">&quot;aaa&quot;</span>,<span class="attr">b</span>:<span class="string">&quot;bbb&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>:b&#125;=&#123;<span class="attr">a</span>:<span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;a,b=<span class="number">5</span>&#125;=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><ul>
<li><p>将变量或表达式直接嵌入字符串</p>
</li>
<li><p>使用反引号（``）拼接多行字符串</p>
</li>
<li><p>ES5</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;john&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">var</span> name = obj.name;</span><br><span class="line">    <span class="keyword">var</span> age = obj.age;</span><br><span class="line">    <span class="built_in">console</span>.log(name + <span class="string">&quot;的年龄是&quot;</span> + age);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> oUl=<span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> html=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    html+=<span class="string">&quot;&lt;li&gt;&quot;</span>+arr[i]+<span class="string">&quot;&lt;li&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">oUl.innerHTML=html;</span><br></pre></td></tr></table></figure></li>
<li><p>ES6</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;join&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name,age&#125;=obj;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>的年龄是<span class="subst">$&#123;age&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> oUl=<span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> html=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">   	html+=<span class="string">`&lt;li&gt;</span></span><br><span class="line"><span class="string">		&lt;a herf=&quot;&quot;&gt;<span class="subst">$&#123;arr[i]&#125;</span>&lt;/a&gt;</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">	&lt;li&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line">oUl.innerHTML=html;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ul>
<li><p>只含有一个表达式</p>
</li>
<li><p>含有多条语句</p>
</li>
<li><p>this的指向问题</p>
</li>
<li><p>没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>
</li>
<li><p>不提供自身的this绑定</p>
</li>
<li><p>```javascript<br>//ES5<br>var foo = function (){</p>
<pre><code>return 1;
</code></pre>
<p>}<br>console.log(foo());</p>
<p>//ES6<br>let foo = () =&gt;1;<br>console.log(foo());<br>//传参进去<br>let foo = (a) =&gt;a;<br>console.log(foo(10));<br>//多条语句<br>let foo = (a) =&gt;{</p>
<pre><code>let b=10;
return a+b;
</code></pre>
<p>}<br>console.log(foo(10));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### this的指向问题</span><br><span class="line"></span><br><span class="line">- ES5普通函数的this指针指向window</span><br><span class="line"></span><br><span class="line">- 箭头函数不提供自身的 this 绑定（`this` 的值将保持为闭合词法上下文的值）。</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  //ES6</span><br><span class="line">  var foo = () =&gt; &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">  foo(); //this指向window</span><br></pre></td></tr></table></figure></li>
<li><p>```javascript<br>//ES5写法</p>
<pre><code>   var name = &quot;window&quot;;
   var obj = &#123;
       &quot;name&quot;: &quot;john&quot;,
       &quot;sayHello&quot;: function() &#123;
           console.log(this.name);
       &#125;
   &#125;
   obj.sayHello();
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  //ES6 this指向定义时所在的作用域而不是执行时的作用域 </span><br><span class="line">          var obj = &#123;</span><br><span class="line">              &quot;name&quot;: &quot;john&quot;,</span><br><span class="line">              //普通的成员函数</span><br><span class="line">              &quot;sayHello&quot;: () =&gt; &#123;</span><br><span class="line">                  console.log(this.name);//this指向window</span><br><span class="line">              &#125;</span><br><span class="line">              //定时器版本</span><br><span class="line">              &quot;sayHello&quot;:function()&#123;</span><br><span class="line">                  setTimeout(()=&gt;&#123;console.log(this.name)&#125;,1000);</span><br><span class="line">              &#125;//john function是在obj里面定义的，所以this指向obj</span><br><span class="line">  			//ES6版本</span><br><span class="line">  			&quot;sayHello&quot;:()=&gt;&#123;</span><br><span class="line">                  setTimeout(()=&gt;&#123;console.log(this.name)&#125;,1000);//此时指向window</span><br><span class="line">          &#125;</span><br><span class="line">          obj.sayHello();</span><br><span class="line">  //相当于下面的代码		</span><br><span class="line">  		var obj = &#123;&#125;;</span><br><span class="line">          obj.name = &quot;john&quot;;</span><br><span class="line">          obj.sayHello = () =&gt; &#123;huan</span><br><span class="line">              console.log(this.name);</span><br><span class="line">          &#125;</span><br><span class="line">          obj.sayHello();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="set结构"><a href="#set结构" class="headerlink" title="set结构"></a>set结构</h4><ul>
<li>```javascript<br>let set = new Set([1,2,3,4,4]);//构造函数  默认删除相同元素[…set]//…扩展运算符，将类数组对象转换以逗号分隔的序列for of//遍历<br>console.log(arr);<br>for (let i of set) {<pre><code>console.log(i); 
</code></pre>
}set.size//长度<br>set.add(0)//加一个元素<br>set.delete(0)//删除一个元素<br>set.has(0)//判断是否含有一个元素<br>set.clear();//清空所有元素keys()//返回键名的遍历器<br>for(let item of set,keys())<br>{<pre><code>console.log(item);
</code></pre>
}values() //返回键值的遍历器<br>for(let item of set,values())<br>{<pre><code>console.log(item);
</code></pre>
}entries() //返回键值对的遍历器<br>for(let [key,item] of set,entries())<br>{<pre><code>console.log(key,item);
</code></pre>
}forEach()//返回回调函数遍历每个成员<br>set.forEach((value,key)=&gt;console.log(value<em>2))<br>/</em><br>2<br>4<br>6<br>8<br>*/<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### map结构</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">let map = new Map([[&quot;name&quot;,&quot;john&quot;],[&quot;age&quot;,30]]);//设置键值对</span><br><span class="line"></span><br><span class="line">map.set(1,1);</span><br><span class="line"></span><br><span class="line">map.size//长度</span><br><span class="line"></span><br><span class="line">map.set(key,value);//添加键值对</span><br><span class="line">map.get(key);//获取键值对</span><br><span class="line">map.delete(key);</span><br><span class="line">map.has(key);</span><br><span class="line">map.clear();</span><br><span class="line"></span><br><span class="line">key();//返回键名的遍历器</span><br><span class="line"></span><br><span class="line">values();//返回键值的遍历器</span><br><span class="line"></span><br><span class="line">entries();//返回键值对的遍历器</span><br><span class="line"></span><br><span class="line">for(let [key,value] ofmap.entries())</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">forEach();//使用回调函数遍历每个成员</span><br><span class="line">map.forEach((value,key)=&gt;console.log(value*2))</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="生成器函数（generator）"><a href="#生成器函数（generator）" class="headerlink" title="生成器函数（generator）"></a>生成器函数（generator）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = foo(<span class="number">1</span>);</span><br><span class="line">f.next();</span><br><span class="line"><span class="built_in">console</span>.log(f.next());</span><br><span class="line"><span class="comment">//Object&#123;</span></span><br><span class="line">	done: <span class="literal">false</span><span class="comment">//表示该生成集函数是否含有相应的yield或者是否结束</span></span><br><span class="line">	<span class="attr">value</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//想要继续运行</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next(),f.next(),f.next());</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//面试题</span></span><br><span class="line"><span class="comment">//next()里面的参数表示上一级的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>*(<span class="keyword">yield</span>(x+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span>(y/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> (x+y+z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">3</span>));<span class="comment">//第一次无论传什么，都是6 即 5+1        value=6</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>));<span class="comment">//yield(x+1)为12，y=24,z=8即24/3	  value=8</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>));<span class="comment">//yield(y/3)为13，z=13			   value=42</span></span><br></pre></td></tr></table></figure>

<p>利用生成器函数编写斐波拉契数列（0    1    1    2    3    5    8    13    21    34…）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">feibo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        <span class="keyword">let</span> tmp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//console.log(tmp);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = feibo(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> f) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>()</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;yyvsu&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line">person.sayHello();</span><br></pre></td></tr></table></figure>

<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul>
<li>Ajax全称：Asynchronous JavaScript And XML</li>
<li>是一种异步加载数据的技术</li>
<li>可以通过使用Ajax，实现页面的局部刷新</li>
<li>可以不用刷新页面就可以从服务器取得数据，实现局部更新页面</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul>
<li>Ajax的核心对象：XMLHttpRequest</li>
<li>XHR就是Ajax</li>
</ul>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><ul>
<li><p>从服务器取得数据</p>
</li>
<li><p>```javascript</p>
<h1></h1>
    <script>
        // 1.创建Ajax对象
        var xhr = new XMLHttpRequest();
        // 2.监听请求
        xhr.onreadystatechange = function() {
                //当xhr对象的readyState属性发生改变，这个事件就会触发
                //readyState:
                // 0 ===>xhr 对象已经创建，但还是没有进行初始化操作
                // 1 ===>xhr对象已经调用了open
                // 2 ===>xhr已经发出ajax请求
                // 3 ===>已经返回了部分数据
                // 4 ===>数据已经全部返回
                if (xhr.readyState != 4) {
                    return;
                }
                //在200到300之间证明请求是成功的
                if (xhr.status > 200 & xhr.status <= 300) {
                    //数据放在了xhr.responseText的属性中(string)
                    document.querySelector('h1').innerHTML = xhr.responseText;
                } else {
                    console.log('请求失败');
                }
            }
            // 3.打开这个对象
        xhr.open('get', 'test.txt', true);
        // 4.发送请求
        xhr.send();
    </script>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">##### POST</span><br><span class="line"></span><br><span class="line">- 向服务器传输数据</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  // 1.创建一个xhr对象</span><br><span class="line">          var xhr = new XMLHttpRequest();</span><br><span class="line">          //5.监听数据返回</span><br><span class="line">          xhr.onreadystatechange = function() &#123;</span><br><span class="line">                  if (xhr.readyState != 4) &#123;</span><br><span class="line">                      return;</span><br><span class="line">                  &#125;</span><br><span class="line">                  //在200到300之间证明请求是成功的</span><br><span class="line">                  if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300) &#123;</span><br><span class="line">                      //数据放在了xhr.responseText的属性中(string)</span><br><span class="line">                      var resp = JSON.parse(xhr.responseText);</span><br><span class="line">                      if (resp.result) &#123;</span><br><span class="line">                          alert(&#x27;登录成功&#x27;);</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          alert(&#x27;运行错误&#x27;)</span><br><span class="line">                      &#125;</span><br><span class="line">  </span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      console.log(&#x27;请求失败&#x27;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              //2.配置这个对象</span><br><span class="line">          xhr.open(&#x27;post&#x27;, &#x27;./login.php&#x27;, true);</span><br><span class="line">          //true表示申请的是异步请求</span><br><span class="line">          //3.设定请求头，指明body中的数据是何格式</span><br><span class="line">          xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencode&#x27;);</span><br><span class="line">          //发送数据</span><br><span class="line">          xhr.send(&#x27;user=gap&amp;password=123456&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li>GET数据放在url中，大小有限制</li>
<li>POST放在请求体中，大小无限制，更安全</li>
</ul>
<h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><ul>
<li>JavaScript Object Natation(JS对象简谱)是一种轻量级的数据交换格式</li>
<li>JSON是ECMA制定的一个数据表示规范</li>
<li>JS对象的子集，与JS无缝对接</li>
<li>JSON数据与JS对象的转换<ul>
<li>JSON-&gt;JS:JSON.parse(data)</li>
<li>JS-&gt;JSON:JSON.stringify(JSObj)</li>
</ul>
</li>
</ul>
<h5 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h5><ul>
<li><p>```javascript<br>//获取数据 </p>
<pre><code>    //要使这三个函数成功前提是假设三个函数都是同步的
    x = getData();
    y = getMoreData(x);
    z = getMoreData(y);


    // 若三个函数是异步的
    //x,y后面的函数就是回调函数
    // 前一次的结果最后后i一次的输入
    getData(function(x) &#123;
        getMoreData(x, function(y) &#123;
            getMoreData(y, function(z) &#123;
                //process z,
            &#125;)
        &#125;)
    &#125;)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 一层层嵌套，这样会导致回调层级很深，导致开发和维护都很难，在ES6中提出了promise这样的对象来解决回调地狱的问题</span><br><span class="line"></span><br><span class="line">##### promise</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  //通过Promise这个构造函数来创建一个对象</span><br><span class="line">  //这个promise对象，有三种状态：padding(准备状态)，fulfill(promise返回满足条件的状态),reject(延时对象没有满足)</span><br><span class="line">  //promise构造函数，有一个参数，这个参数是一个回调函数。这个回调，接收两个参数，这两个参数，都能够改变promise对象的状态</span><br><span class="line">  //第一个参数可以将状态从pending===&gt;fulfill,而第二个参数，可以将状态从pending===&gt;reject</span><br><span class="line">  //fulfill表示调用成功，reject表示调用失败</span><br><span class="line">  // var promise = new Promise(function(resolve, reject) &#123;//回调参数</span><br><span class="line">  //     if ( /*成功*/ ) &#123;</span><br><span class="line">  //         resolve()</span><br><span class="line">  //     &#125; else &#123;</span><br><span class="line">  //         reject();</span><br><span class="line">  //     &#125;</span><br><span class="line">  // &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>Ajax对调用顺序是有依赖性的</p>
</li>
<li><pre><code class="javascript">&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var article = &#39; &#39;;
        $.get(&#39;./p1.txt&#39;, function(p1) &#123;
            article += p1 + &#39;&lt;br&gt;&#39;;
            $.get(&#39;./p2.txt&#39;, function(p2) &#123;
                article += p2 + &#39;&lt;br&gt;&#39;;
                $.get(&#39;./p3.txt&#39;, function(p3) &#123;
                    article += p3 + &#39;&lt;br&gt;&#39;;
                    $.get(&#39;./p4.txt&#39;, function(p4) &#123;
                        article += p4 + &#39;&lt;br&gt;&#39;;
                        $(&#39;p&#39;).html(article);
                    &#125;)
                &#125;)
            &#125;)
        &#125;)
    &lt;/script&gt;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>更新Blog时的一些注意点</title>
    <url>/2022/01/06/%E6%9B%B4%E6%96%B0Blog%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<h2 id="1-查看版本号"><a href="#1-查看版本号" class="headerlink" title="1. 查看版本号"></a>1. 查看版本号</h2><ol>
<li><p>Hexo：<br>在自己博客文档里面的package.json文档中搜索version即可找到</p>
</li>
<li><p>hexo-cli<br>在package-lock.json文档中直接搜索hexo-cli</p>
</li>
<li><p>node</p>
<p>node -v</p>
</li>
<li><p>git</p>
<p>git version</p>
</li>
</ol>
<h2 id="2-markdown文档"><a href="#2-markdown文档" class="headerlink" title="2. markdown文档"></a>2. markdown文档</h2><ol>
<li><p>markdown文档的格式要求</p>
<p><a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p>
</li>
<li><p>表头 Front-matter</p>
<p><img src="https://res.cloudinary.com/dqro6ugug/image/upload/v1641452691/blog/image-20220105151114207_ujaddi.png"></p>
<ol>
<li><p>page front-matter</p>
<p><img src="https://res.cloudinary.com/dqro6ugug/image/upload/v1641452817/blog/image-20220105151235909_osjlbr.png"></p>
</li>
<li><p>post front-matter</p>
<p><img src="https://res.cloudinary.com/dqro6ugug/image/upload/v1641453046/blog/screenshot-butterfly.js.org-2022.01.05-15_13_00_damz5g.png"></p>
</li>
</ol>
</li>
<li><p>文章封面在front-matter中设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cover: &#x27;文章的url&#x27;</span><br><span class="line">||</span><br><span class="line">cover: </span><br><span class="line">  # 是否显示文章封面</span><br><span class="line">  index_enable: true</span><br><span class="line">  aside_enable: true</span><br><span class="line">  archives_enable: true</span><br><span class="line">  # 封面显示的位置</span><br><span class="line">  # 三个值可配置 left , right , both</span><br><span class="line">  position: both</span><br><span class="line">  # 当没有设置cover时，默认的封面显示</span><br><span class="line">  default_cover: </span><br></pre></td></tr></table></figure></li>
<li><p>外挂标签</p>
<p>自行借鉴butterfly主题中的外挂标签使用：<br><a href="https://butterfly.js.org/posts/4aa8abbe/#Note-Bootstrap-Callout">https://butterfly.js.org/posts/4aa8abbe/#Note-Bootstrap-Callout</a></p>
</li>
</ol>
<h2 id="3-一些命令语句"><a href="#3-一些命令语句" class="headerlink" title="3. 一些命令语句"></a>3. 一些命令语句</h2><ol>
<li><p>创建草稿</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;草稿标题&quot;</span><br></pre></td></tr></table></figure>

<p>静态网站中不会出现草稿文章</p>
</li>
<li><p>生成博客文章</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>生程纯页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;文章标题&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>生成静态文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li>
<li><p>渲染静态网站</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-评论模块"><a href="#4-评论模块" class="headerlink" title="4. 评论模块"></a>4. 评论模块</h2><p>emoji是借用其他人的emojiCDN，网址为：<a href="https://cungudafa.blog.csdn.net/article/details/105548858">https://cungudafa.blog.csdn.net/article/details/105548858</a></p>
<p>自己建立valine.json或者valine.yml时一直没有调试出来，无法自行显示表情包，但我删除这些文件后，在_config.butterfly.yml中设置为如下代码，表情包便成功显示出来，并能够使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emojiCDN: &#x27;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/&#x27;</span><br><span class="line">enableQQ: true # enable the Nickname box to automatically get QQ Nickname and QQ Avatar</span><br><span class="line">emojiMaps: &#123;&#125; </span><br></pre></td></tr></table></figure>

<h2 id="5-未解决的问题"><a href="#5-未解决的问题" class="headerlink" title="5. 未解决的问题"></a>5. 未解决的问题</h2><ol>
<li>标签页和分类页的头部图片无法设置</li>
</ol>
<h2 id="6-提交blog"><a href="#6-提交blog" class="headerlink" title="6. 提交blog"></a>6. 提交blog</h2><p>正常提交方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注意：提交时需要先执行这个命令</span><br><span class="line"># 作用：清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">hexo clean</span><br><span class="line"># 生成静态文件</span><br><span class="line">hexo g</span><br><span class="line"># 部署网站</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>如果出现类似如下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/a956551943/a956551943.github.io/&#x27;: Encountered end of file</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (/usr/local/src/hexo/hanyubolg/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:376:20)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>

<p>可以使用如下方法提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##进入站点根目录</span><br><span class="line">cd /usr/local/src/hexo/hanyubolg/</span><br><span class="line"></span><br><span class="line">##删除git提交内容文件夹</span><br><span class="line">rm -rf .deploy_git/</span><br><span class="line"></span><br><span class="line">##执行</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line"></span><br><span class="line">##最后</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>更新</category>
      </categories>
  </entry>
</search>
